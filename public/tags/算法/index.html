<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>算法 | tyhzxh的个人博客</title><meta name=keywords content><meta name=description content="分享技术、思考与生活的个人博客"><meta name=author content="tyhzxh"><link rel=canonical href=https://tyhzxh.github.io/tags/%E7%AE%97%E6%B3%95/><link crossorigin=anonymous href=/assets/css/stylesheet.8ee78296343cf29844826f6d943ca1b6638fc5059dcdf673ace996a7617f1b69.css integrity="sha256-jueCljQ88phEgm9tlDyhtmOPxQWdzfZzrOmWp2F/G2k=" rel="preload stylesheet" as=style><link rel=icon href=https://tyhzxh.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tyhzxh.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tyhzxh.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tyhzxh.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tyhzxh.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://tyhzxh.github.io/tags/%E7%AE%97%E6%B3%95/index.xml><link rel=alternate hreflang=en href=https://tyhzxh.github.io/tags/%E7%AE%97%E6%B3%95/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://tyhzxh.github.io/tags/%E7%AE%97%E6%B3%95/"><meta property="og:site_name" content="tyhzxh的个人博客"><meta property="og:title" content="算法"><meta property="og:description" content="分享技术、思考与生活的个人博客"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="算法"><meta name=twitter:description content="分享技术、思考与生活的个人博客"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tyhzxh.github.io/ accesskey=h title="tyhzxh的个人博客 (Alt + H)">tyhzxh的个人博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tyhzxh.github.io/ title=首页><span>首页</span></a></li><li><a href=https://tyhzxh.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://tyhzxh.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://tyhzxh.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://tyhzxh.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://tyhzxh.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://tyhzxh.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://tyhzxh.github.io/tags/>Tags</a></div><h1>算法</h1></header><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src="https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=800&amp;h=400&amp;fit=crop" alt=双指针算法示意图></figure><header class=entry-header><h2 class=entry-hint-parent>双指针算法详解</h2></header><div class=entry-content><p>介绍 双指针是一种常用的算法技巧，通过使用两个指针来遍历数据结构，可以有效地减少时间复杂度，从O(n²)降低到O(n)。双指针的类型主要有以下几种：
1. 对撞指针（Two Pointers from Two Sides） 两个指针分别从数组或链表的两端开始，向中间移动，直到相遇或者满足某个条件。这种方法适用于有序数组或链表，可以用于查找和问题、乘积和问题等。
2. 快慢指针（Fast and Slow Pointers） 两个指针从同一位置开始，一个指针（快指针）移动的速度是另一个指针（慢指针）的两倍。这种方法常用于链表问题，比如判断链表是否有环，或者找到链表的中间节点。
3. 左右指针（Left and Right Pointers） 两个指针分别从数组的两端开始，向中间移动。这种方法适用于有序数组，可以用于查找特定元素或者解决三数之和问题。
4. 无序指针 如果两个指针没有任何语义和逻辑顺序，只是用于指向不同的地址，也可以直接简单命名。例如，在合并两个有序链表的问题中，可以使用两个无序指针分别指向链表1和链表2。
应用场景 双指针算法的关键在于如何移动这两个指针。双指针技巧通常用于解决涉及数组或链表的问题，它可以帮助我们以线性时间复杂度解决问题，而不是使用嵌套循环导致的时间复杂度为O(n²)。
常见使用场景： 滑动窗口问题：当需要找到一个子数组或子串，使得它满足特定条件（如最大和、最小和、包含特定元素等）时，可以使用双指针来维护一个滑动窗口。
有序数组中的查找问题：如果有两个有序数组，需要找到两个数组的第k小的数，或者判断一个数组是否是另一个数组的子集，可以使用双指针。
链表问题：在链表中找到中间节点、删除链表中的节点、合并两个有序链表等问题，通常使用快慢指针。
数组中的成对问题：需要在数组中找到两个数，它们的和为特定值（如"两数之和"问题），或者需要找到两个数，它们的乘积为特定值。
循环数组问题：当数组是循环的，需要找到重复的元素或者满足特定条件的元素对时，可以使用双指针。
数组中的连续子数组问题：需要找到连续的子数组，使得它们的和满足特定条件，或者找到最长的连续子数组，使得它们满足特定条件。
算法优势 双指针技巧在解决特定问题时具有显著的优势：
1. 时间复杂度优化 双指针可以减少不必要的重复计算，尤其是在处理有序数组或链表时，可以避免使用嵌套循环导致的二次方时间复杂度，通常可以将时间复杂度降低到线性时间复杂度O(n)。
2. 空间复杂度优化 双指针通常只需要常数级别的额外空间，这比使用额外的数据结构（如哈希表）要节省空间。
3. 简化问题 双指针可以将复杂问题简化为更简单的形式。例如，在滑动窗口问题中，双指针可以动态地维护一个窗口，而不需要每次都重新计算窗口内的元素。
4. 灵活性和适应性 双指针技巧非常灵活，可以根据问题的不同需求调整指针的移动策略，如可以同时向中间移动，也可以一个向前移动而另一个向后移动。
滑动窗口 滑动窗口（Sliding Window）是一种在数组或字符串上进行操作的算法策略，主要用于解决需要在连续子数组或子字符串上满足特定条件的问题。
为什么叫滑动窗口？ “滑动窗口"这个名字的由来是因为这种算法的操作方式类似于一个可以沿着数组或字符串滑动的窗口。窗口可以扩大或缩小，以包含不同的元素，直到找到满足条件的子数组或子字符串。
滑动窗口的特点： 连续性：窗口内的元素是连续的，不需要是整个数组或字符串的子集。 动态性：窗口的大小可以根据需要动态调整，窗口的边界可以向前或向后移动。 实时性：窗口可以实时地检查当前窗口内的数据是否满足条件。 滑动窗口的实现： 滑动窗口通常使用双指针（或索引）来实现，一个指针表示窗口的开始，另一个指针表示窗口的结束。通过移动这两个指针，可以动态地调整窗口的大小和位置。
扩展窗口：通常通过移动结束指针（右指针）向右来实现，这样可以包含更多的元素。 收缩窗口：通常通过移动开始指针（左指针）向右来实现，这样可以排除窗口中的第一个元素。 经典算法实现 1. 对撞指针示例 问题描述：找出数组中乘积小于K的连续子数组的最大长度。
def maxProductSubarray(nums, k): left, right = 0, 0 max_length = 0 product = 1 while right &lt; len(nums): product *= nums[right] while left &lt;= right and product >= k: product /= nums[left] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length 2. 快慢指针示例 问题描述：判断链表是否有环，并返回环的入口节点。
...</p></div><footer class=entry-footer><span title='2024-10-24 19:52:26 +0800 CST'>October 24, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;tyhzxh</footer><a class=entry-link aria-label="post link to 双指针算法详解" href=https://tyhzxh.github.io/posts/two-pointers-algorithm/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src="https://images.unsplash.com/photo-1518186285589-2f7649de83e0?w=800&amp;h=400&amp;fit=crop" alt=排序算法可视化></figure><header class=entry-header><h2 class=entry-hint-parent>经典排序算法实现与分析</h2></header><div class=entry-content><p>前言 这是某次学校数据结构实验中实现的基本排序算法。数据结构这门课的难点在于实现的复杂性，每次实验都需要封装数据结构，编写测试程序，对于初学者来说确实是一个挑战。
通过这次实验，我深刻体会到了代码质量的重要性。虽然当时的代码可能不够优雅，但这正是学习过程中的宝贵经历。
基本数据结构封装 首先定义基本的数据结构和工具函数：
#include "stdio.h" #include &lt;iostream> #include &lt;ctime> #include &lt;cstdlib> #define ERROR 0 #define OK 1 #define Overflow 2 #define Underflow 3 #define NotPresent 4 // 元素不存在 #define Duplicate 5 // 元素重复存在 #define MaxSize 100001 typedef int KeyType; typedef int Status; typedef int DataType; typedef struct Entry { KeyType key; DataType data; } entry; typedef struct list { int n; Entry D[MaxSize]; } List; // 输出函数 Status printlist(list* l) { for(int i = 0; i &lt; l->n; i++) { printf("%d ", l->D[i].key); } return OK; } // 交换函数 void swap(Entry* a, Entry* b) { Entry temp = *a; *a = *b; *b = temp; } 排序算法实现 1. 简单选择排序 选择排序的基本思想是每次从未排序的元素中选择最小的元素，放到已排序序列的末尾。
...</p></div><footer class=entry-footer><span title='2024-02-27 22:11:13 +0800 CST'>February 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;tyhzxh</footer><a class=entry-link aria-label="post link to 经典排序算法实现与分析" href=https://tyhzxh.github.io/posts/sorting-algorithms-implementation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>动态规划完全攻略：从入门到精通</h2></header><div class=entry-content><p>今天开始！DP！针对动态规划（DP）的系统训练，这是一套完整的训练方案，从核心思维到高频题型再到实战技巧全面覆盖。
一、动态规划核心思维训练 1. 破除两大误区 ❌ 误区1：必须找到最优子结构才能用DP
✅ 正确姿势：先暴力递归 → 发现重叠子问题 → 改记忆化搜索 → 再推导DP方程
❌ 误区2：DP必须用数组存储状态
✅ 正确姿势：学会状态压缩（如打家劫舍用两个变量代替数组）
2. 四步解题法（用爬楼梯问题实践） # 原题：每次爬1或2阶，到n阶有多少种方法？ # 1. 定义状态：dp[i]表示到i阶的方法数 # 2. 初始状态：dp[0]=1, dp[1]=1（注意不是常规的dp[0]=0） # 3. 状态转移：dp[i] = dp[i-1] + dp[i-2] # 4. 优化空间：只需prev和curr两个变量滚动计算 def climbStairs(n): if n &lt;= 1: return 1 prev, curr = 1, 1 for i in range(2, n+1): prev, curr = curr, prev + curr return curr 3. 高频状态转移类型 类型 经典例题 状态转移关键点 单序列线性DP 打家劫舍(198) dp[i] = max(dp[i-1], dp[i-2]+nums[i]) 双序列匹配DP 最长公共子序列(1143) dp[i][j] = 1+dp[i-1][j-1] if s[i]==t[j] 区间DP 最长回文子串(5) dp[i][j] = (s[i]==s[j]) and dp[i+1][j-1] 背包DP 分割等和子集(416) dp[j] = dp[j] or dp[j-num] 状态机DP 买卖股票最佳时机(121/122) 持有/未持有两种状态转换 二、阶梯式训练路线 阶段1：基础模型搭建（1-2周） 题目 训练重点 突破技巧 70. 爬楼梯 斐波那契型DP 空间压缩到O(1) 118. 杨辉三角 二维DP填表逻辑 观察行列关系 121. 买卖股票的最佳时机 状态机模型 维护min_price和max_profit 53. 最大子数组和 决策型DP（选或不选） 用curr_max代替dp数组 746. 使用最小花费爬楼梯 路径成本计算 逆向推导更简单 阶段2：经典题型突破（2-3周） 题目 难点解析 代码模板片段 198. 打家劫舍 相邻不能选 max(dp[i-1], dp[i-2]+nums[i]) 322. 零钱兑换 完全背包最小值 dp[amt] = min(dp[amt], dp[amt-coin]+1) 300. 最长递增子序列 O(n²)与O(nlogn)两种解法 二分查找维护tails数组 1143. 最长公共子序列 双序列匹配 if s[i]==t[j]: dp[i][j]=dp[i-1][j-1]+1 139. 单词拆分 字符串分段判断 dp[i] = any(dp[j] and s[j:i] in dict) 阶段3：高难度挑战（3-4周） 题目 破题关键点 优化技巧 72. 编辑距离 三种操作的状态转移 空间压缩到一维数组 152. 乘积最大子数组 处理负数乘积 同时维护max和min 312. 戳气球 区间DP逆向思维 从最后戳破的气球倒推 10. 正则表达式匹配 星号匹配的特殊处理 分情况讨论pattern的第二个字符 887. 鸡蛋掉落 决策最优化的数学推导 逆向思维+二分查找优化 三、避坑指南与实战技巧 1. 五大常见错误类型 🚫 初始化错误：比如背包问题中dp[0]应该初始化为True 🚫 遍历顺序错误：完全背包要正序循环，01背包要倒序循环 🚫 状态转移遗漏：如编辑距离忘记考虑replace操作 🚫 二维DP行列混淆：把s的长度当作行还是列要统一 🚫 空间压缩陷阱：覆盖未使用的旧值导致错误 2. 三步优化方法论 1. **暴力递归** → 写出基本状态转移 - 斐波那契数列递归版 2. **记忆化搜索** → 添加缓存（@lru_cache） - 用装饰器自动缓存参数 3. **推导DP方程** → 优化空间复杂度 - 观察状态依赖关系，压缩维度 3. 面试应答技巧 💡 先说出暴力解的时间复杂度 💡 明确说出DP数组的定义和维度 💡 在白板上先写状态转移方程再编码 💡 主动讨论空间优化可能性 四、配套训练资源 1. 可视化学习 DPV 算法可视化网站 - 动态展示DP执行过程 VisuAlgo 动态规划专题 - 包含LCS、背包等问题动画 2. 专项题单 LeetCode动态规划分类 → 按通过率排序练习 经典DP问题Top 50 → 涵盖所有DP类型 3. 错题本模板 ## 72. 编辑距离 ### 错误记录 - 初始版本忘记处理空字符串情况 - 误将替换操作的成本计算为2（正确是1） ### 状态转移表 | | "" | r | o | s | |-------|----|---|---|---| | "" | 0 | 1 | 2 | 3 | | h | 1 | 1 | 2 | 3 | | o | 2 | 2 | 1 | 2 | | r | 3 | 2 | 2 | 2 | | s | 4 | 3 | 3 | 2 | 五、训练计划建议 每日任务 上午：精做1道新DP题（按阶段选择难度） 下午：复习2道旧题，写出空间优化版本 晚上：观看对应题目的讲解视频 每周检验 周赛至少完成2道DP相关题目 整理本周的DP类型思维导图 预期效果 坚持按照这个方案训练2个月后，你会明显发现：
...</p></div><footer class=entry-footer><span title='2024-02-27 22:05:43 +0800 CST'>February 27, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;tyhzxh</footer><a class=entry-link aria-label="post link to 动态规划完全攻略：从入门到精通" href=https://tyhzxh.github.io/posts/dynamic-programming-guide/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src="https://images.unsplash.com/photo-1518186285589-2f7649de83e0?w=800&amp;h=400&amp;fit=crop" alt=搜索算法与图论></figure><header class=entry-header><h2 class=entry-hint-parent>搜索算法详解：BFS与DFS的原理和应用</h2></header><div class=entry-content><p>搜索算法概述 搜索算法是计算机科学中的基础算法，用于在数据结构中查找特定元素或路径。在图论和树结构中，最重要的两种搜索算法是广度优先搜索（BFS）和深度优先搜索（DFS）。
广度优先搜索（BFS） BFS基本原理 **广度优先搜索（Breadth-First Search）**是一种图遍历算法，它从起始节点开始，逐层向外扩展，先访问距离起始节点最近的所有节点，再访问距离更远的节点。
BFS核心特点 特点 描述 应用场景 层次遍历 按距离起始点的层次逐层访问 最短路径问题 队列实现 使用队列（FIFO）存储待访问节点 保证访问顺序 完备性 如果解存在，一定能找到 状态空间搜索 最优性 在无权图中能找到最短路径 最短路径算法 BFS算法实现 1. 基础BFS模板 from collections import deque def bfs_template(graph, start): """ BFS算法通用模板 Args: graph: 图的邻接表表示 {node: [neighbors]} start: 起始节点 Returns: visited: 访问过的节点集合 """ visited = set() queue = deque([start]) visited.add(start) while queue: current = queue.popleft() print(f"访问节点: {current}") # 遍历当前节点的所有邻居 for neighbor in graph.get(current, []): if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return visited # 示例图 graph = { 'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E'] } visited_nodes = bfs_template(graph, 'A') print("BFS访问的节点:", visited_nodes) 2. BFS求最短路径 def bfs_shortest_path(graph, start, target): """ 使用BFS求无权图中的最短路径 Args: graph: 图的邻接表 start: 起始节点 target: 目标节点 Returns: (distance, path): 最短距离和路径 """ if start == target: return 0, [start] visited = set([start]) queue = deque([(start, 0, [start])]) # (节点, 距离, 路径) while queue: current, distance, path = queue.popleft() for neighbor in graph.get(current, []): if neighbor == target: return distance + 1, path + [neighbor] if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, distance + 1, path + [neighbor])) return -1, [] # 无法到达 # 示例使用 distance, path = bfs_shortest_path(graph, 'A', 'F') print(f"从A到F的最短距离: {distance}") print(f"最短路径: {' -> '.join(path)}") 3. BFS层次遍历 def bfs_level_order(graph, start): """ BFS层次遍历，返回每一层的节点 Args: graph: 图的邻接表 start: 起始节点 Returns: levels: 每一层的节点列表 """ visited = set([start]) current_level = [start] levels = [] while current_level: levels.append(current_level[:]) # 复制当前层 next_level = [] for node in current_level: for neighbor in graph.get(node, []): if neighbor not in visited: visited.add(neighbor) next_level.append(neighbor) current_level = next_level return levels # 示例使用 levels = bfs_level_order(graph, 'A') for i, level in enumerate(levels): print(f"第{i}层: {level}") BFS在二叉树中的应用 class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bfs_tree_traversal(root): """ 二叉树的BFS遍历（层序遍历） Args: root: 二叉树根节点 Returns: result: 层序遍历结果 """ if not root: return [] result = [] queue = deque([root]) while queue: node = queue.popleft() result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result def bfs_tree_level_order(root): """ 二叉树的分层遍历 Args: root: 二叉树根节点 Returns: levels: 每一层的节点值列表 """ if not root: return [] levels = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) levels.append(current_level) return levels # 构建示例二叉树 # 3 # / \ # 9 20 # / \ # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) print("BFS遍历:", bfs_tree_traversal(root)) print("分层遍历:", bfs_tree_level_order(root)) 深度优先搜索（DFS） DFS基本原理 **深度优先搜索（Depth-First Search）**是一种图遍历算法，它从起始节点开始，沿着一条路径尽可能深入，直到无法继续为止，然后回溯到上一个节点，继续探索其他路径。
...</p></div><footer class=entry-footer><span title='2024-02-27 22:05:13 +0800 CST'>February 27, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;tyhzxh</footer><a class=entry-link aria-label="post link to 搜索算法详解：BFS与DFS的原理和应用" href=https://tyhzxh.github.io/posts/search-algorithms-guide/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src="https://images.unsplash.com/photo-1635070041078-e363dbe005cb?w=800&amp;h=400&amp;fit=crop" alt=汉诺塔问题示意图></figure><header class=entry-header><h2 class=entry-hint-parent>递归与分治算法详解</h2></header><div class=entry-content><p>递归算法概述 递归是一种重要的算法设计思想，它将复杂问题分解为规模更小的同类子问题来解决。递归算法的核心在于找到问题的递归关系和边界条件。
经典汉诺塔问题 汉诺塔是学习递归算法的经典问题。这个问题看似简单，但蕴含着深刻的递归思想。
问题描述 有三根柱子A、B、C，n个圆盘从下面开始按大小顺序摆放在A柱子上。规则如下：
任何时候，小圆盘上都不能放大圆盘 三根柱子之间一次只能移动一个圆盘 求将所有圆盘从A柱移动到C柱的最少移动步骤 递归解法 核心思想 要将n个盘子从A移动到C，可以分解为三个步骤：
将上面的n-1个盘子从A移动到B（以C为辅助） 将最大的盘子从A移动到C 将n-1个盘子从B移动到C（以A为辅助） 递归公式 Hanoi(A, C, B, n) = Hanoi(A, B, C, n-1) + move(A, C, n) + Hanoi(B, C, A, n-1) 其中：
Hanoi(A, C, B, n) 表示将n个盘子从A柱移动到C柱，B柱作为辅助 move(A, C, n) 表示将编号为n的盘子从A移动到C 代码实现 #include &lt;iostream> using namespace std; void move(char from, char to, int disk) { cout &lt;&lt; "移动盘子 " &lt;&lt; disk &lt;&lt; ": " &lt;&lt; from &lt;&lt; " --> " &lt;&lt; to &lt;&lt; endl; } void hanoi(char from, char to, char aux, int n) { if (n == 1) { // 边界条件：只有一个盘子时，直接移动 move(from, to, n); } else { // 递归步骤1：将上面n-1个盘子移动到辅助柱 hanoi(from, aux, to, n - 1); // 递归步骤2：移动最大的盘子 move(from, to, n); // 递归步骤3：将n-1个盘子从辅助柱移动到目标柱 hanoi(aux, to, from, n - 1); } } int main() { int n; cout &lt;&lt; "请输入盘子数量: "; cin >> n; cout &lt;&lt; "汉诺塔移动步骤：" &lt;&lt; endl; hanoi('A', 'C', 'B', n); return 0; } Python版本实现 def move(from_pole, to_pole, disk): """移动单个盘子""" print(f"移动盘子 {disk}: {from_pole} --> {to_pole}") def hanoi(from_pole, to_pole, aux_pole, n): """ 汉诺塔递归解法 from_pole: 起始柱 to_pole: 目标柱 aux_pole: 辅助柱 n: 盘子数量 """ if n == 1: # 边界条件：只有一个盘子时，直接移动 move(from_pole, to_pole, n) else: # 步骤1：将上面n-1个盘子移动到辅助柱 hanoi(from_pole, aux_pole, to_pole, n - 1) # 步骤2：移动最大的盘子到目标柱 move(from_pole, to_pole, n) # 步骤3：将n-1个盘子从辅助柱移动到目标柱 hanoi(aux_pole, to_pole, from_pole, n - 1) def count_moves(n): """计算移动次数""" return 2**n - 1 # 示例使用 if __name__ == "__main__": n = int(input("请输入盘子数量: ")) print(f"\n{n}个盘子的汉诺塔移动步骤：") hanoi('A', 'C', 'B', n) print(f"\n总移动次数: {count_moves(n)}") 递归的本质理解 1. 递归是一种树形结构 递归算法的执行过程可以看作是一棵树：
...</p></div><footer class=entry-footer><span title='2024-02-27 22:03:04 +0800 CST'>February 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;tyhzxh</footer><a class=entry-link aria-label="post link to 递归与分治算法详解" href=https://tyhzxh.github.io/posts/recursion-and-divide-conquer/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src="https://images.unsplash.com/photo-1509228468518-180dd4864904?w=800&amp;h=400&amp;fit=crop" alt=算法思维与优化></figure><header class=entry-header><h2 class=entry-hint-parent>贪心算法详解：从基础概念到经典问题</h2></header><div class=entry-content><p>贪心算法概述 **贪心算法（Greedy Algorithm）**是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。贪心算法在算法竞赛和实际工程中都有着重要的地位。
贪心算法的核心思想 基本原理 贪心算法的核心思想是：
局部最优选择：在每一步都做出当前看起来最优的选择 不回溯：一旦做出选择，就不再改变 希望全局最优：通过局部最优选择达到全局最优解 贪心选择性质 一个问题能够用贪心算法解决，必须具备以下性质：
性质 描述 重要性 贪心选择性质 通过局部最优选择能达到全局最优 核心性质 最优子结构 问题的最优解包含子问题的最优解 必要条件 无后效性 当前选择不影响之前的选择 保证正确性 贪心算法设计步骤 1. 问题分析 def greedy_algorithm_template(problem_input): """ 贪心算法通用模板 """ # 步骤1：将问题分解为子问题 subproblems = decompose_problem(problem_input) # 步骤2：确定贪心策略 strategy = define_greedy_strategy() # 步骤3：按贪心策略排序 sorted_items = sort_by_strategy(subproblems, strategy) # 步骤4：逐步构造解 solution = [] for item in sorted_items: if is_feasible(solution, item): solution.append(item) return solution 2. 贪心策略选择 常见的贪心策略包括：
策略类型 描述 适用场景 最大优先 优先选择最大值 最大收益问题 最小优先 优先选择最小值 最小成本问题 比值优先 按某种比值排序 效率优化问题 截止时间优先 按时间排序 调度问题 经典贪心算法问题 1. 活动选择问题 问题描述 给定n个活动，每个活动都有开始时间和结束时间，选择最多的活动使得它们不冲突。
...</p></div><footer class=entry-footer><span title='2024-02-27 22:02:23 +0800 CST'>February 27, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;tyhzxh</footer><a class=entry-link aria-label="post link to 贪心算法详解：从基础概念到经典问题" href=https://tyhzxh.github.io/posts/greedy-algorithm-guide/></a></article><article class="post-entry tag-entry"><figure class=entry-cover><img loading=lazy src="https://images.unsplash.com/photo-1509228468518-180dd4864904?w=800&amp;h=400&amp;fit=crop" alt=前缀和算法示意图></figure><header class=entry-header><h2 class=entry-hint-parent>前缀和算法详解与应用</h2></header><div class=entry-content><p>前缀和算法概述 前缀和是一种重要的算法技巧，主要用于快速计算数组区间内的各种统计信息。通过预处理构建前缀数组，可以将原本需要O(n)时间复杂度的区间查询优化到O(1)。
前缀和算法的核心思想是：利用前面已经计算过的结果来快速得出当前的结果。
前缀和的基本类型 1. 累计值前缀数组（用于区间求和） 这是最常见的前缀和应用，用于快速计算数组中任意区间的元素和。
def build_prefix_sum(arr): """构建前缀和数组""" prefix_sum = [0] # 初始化前缀和数组，第一个元素为0 for num in arr: prefix_sum.append(prefix_sum[-1] + num) # 将当前元素加到前一个前缀和上 return prefix_sum def range_sum(prefix_sum, start, end): """计算区间和""" return prefix_sum[end + 1] - prefix_sum[start] # 示例使用 arr = [1, 2, 3, 4, 5] prefix_sum = build_prefix_sum(arr) print(f"原数组: {arr}") print(f"前缀和数组: {prefix_sum}") # 查询区间 [1, 3] 的和 (索引1到3，即元素2, 3, 4) result = range_sum(prefix_sum, 1, 3) print(f"区间 [1, 3] 的和: {result}") # 输出 9 (2 + 3 + 4) 算法解释：
build_prefix_sum 函数通过遍历输入数组并累加每个元素来构建前缀和数组 前缀和数组的第一个元素初始化为0，表示空区间的和 range_sum 函数利用前缀和的性质：区间[start, end]的和 = prefix_sum[end+1] - prefix_sum[start] 2. 累计出现次数前缀数组 用于快速查询某个特定值在指定区间内的出现次数。
def build_prefix_count(arr, target): """构建目标值的前缀计数数组""" prefix_count = [0] # 初始化前缀计数数组 for num in arr: if num == target: prefix_count.append(prefix_count[-1] + 1) # 如果是目标值，计数加1 else: prefix_count.append(prefix_count[-1]) # 否则，计数不变 return prefix_count def count_range_occurrences(prefix_count, start, end): """计算区间内目标值的出现次数""" return prefix_count[end + 1] - prefix_count[start] # 示例使用 arr = [1, 3, 2, 3, 3, 4] target = 3 prefix_count = build_prefix_count(arr, target) print(f"原数组: {arr}") print(f"目标值 {target} 的前缀计数数组: {prefix_count}") # 查询区间 [1, 4] 中目标值的出现次数 result = count_range_occurrences(prefix_count, 1, 4) print(f"区间 [1, 4] 中值 {target} 的出现次数: {result}") # 输出 3 算法解释：
...</p></div><footer class=entry-footer><span title='2024-02-23 13:34:50 +0800 CST'>February 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;tyhzxh</footer><a class=entry-link aria-label="post link to 前缀和算法详解与应用" href=https://tyhzxh.github.io/posts/prefix-sum-algorithm/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://tyhzxh.github.io/>tyhzxh的个人博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>