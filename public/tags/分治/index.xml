<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>分治 on tyhzxh的个人博客</title><link>https://tyhzxh.github.io/tags/%E5%88%86%E6%B2%BB/</link><description>Recent content in 分治 on tyhzxh的个人博客</description><generator>Hugo -- 0.148.2</generator><language>zh-cn</language><lastBuildDate>Wed, 06 Aug 2025 08:51:21 +0800</lastBuildDate><atom:link href="https://tyhzxh.github.io/tags/%E5%88%86%E6%B2%BB/index.xml" rel="self" type="application/rss+xml"/><item><title>递归与分治算法详解</title><link>https://tyhzxh.github.io/posts/recursion-and-divide-conquer/</link><pubDate>Tue, 27 Feb 2024 22:03:04 +0800</pubDate><guid>https://tyhzxh.github.io/posts/recursion-and-divide-conquer/</guid><description>深入解析递归与分治算法的核心思想，以经典汉诺塔问题为例，详细讲解递归算法的设计思路和实现方法</description><content:encoded><![CDATA[<h2 id="递归算法概述">递归算法概述</h2>
<p>递归是一种重要的算法设计思想，它将复杂问题分解为规模更小的同类子问题来解决。递归算法的核心在于找到问题的<strong>递归关系</strong>和<strong>边界条件</strong>。</p>
<h2 id="经典汉诺塔问题">经典汉诺塔问题</h2>
<p>汉诺塔是学习递归算法的经典问题。这个问题看似简单，但蕴含着深刻的递归思想。</p>
<h3 id="问题描述">问题描述</h3>
<p>有三根柱子A、B、C，n个圆盘从下面开始按大小顺序摆放在A柱子上。规则如下：</p>
<ol>
<li>任何时候，小圆盘上都不能放大圆盘</li>
<li>三根柱子之间一次只能移动一个圆盘</li>
<li>求将所有圆盘从A柱移动到C柱的最少移动步骤</li>
</ol>
<h3 id="递归解法">递归解法</h3>
<h4 id="核心思想">核心思想</h4>
<p>要将n个盘子从A移动到C，可以分解为三个步骤：</p>
<ol>
<li>将上面的n-1个盘子从A移动到B（以C为辅助）</li>
<li>将最大的盘子从A移动到C</li>
<li>将n-1个盘子从B移动到C（以A为辅助）</li>
</ol>
<h4 id="递归公式">递归公式</h4>
<pre tabindex="0"><code>Hanoi(A, C, B, n) = Hanoi(A, B, C, n-1) + move(A, C, n) + Hanoi(B, C, A, n-1)
</code></pre><p>其中：</p>
<ul>
<li><code>Hanoi(A, C, B, n)</code> 表示将n个盘子从A柱移动到C柱，B柱作为辅助</li>
<li><code>move(A, C, n)</code> 表示将编号为n的盘子从A移动到C</li>
</ul>
<h4 id="代码实现">代码实现</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">move</span><span class="p">(</span><span class="kt">char</span> <span class="n">from</span><span class="p">,</span> <span class="kt">char</span> <span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">disk</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;移动盘子 &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">disk</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">from</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; --&gt; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">to</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">hanoi</span><span class="p">(</span><span class="kt">char</span> <span class="n">from</span><span class="p">,</span> <span class="kt">char</span> <span class="n">to</span><span class="p">,</span> <span class="kt">char</span> <span class="n">aux</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 边界条件：只有一个盘子时，直接移动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">move</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 递归步骤1：将上面n-1个盘子移动到辅助柱
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">hanoi</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">aux</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 递归步骤2：移动最大的盘子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">move</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 递归步骤3：将n-1个盘子从辅助柱移动到目标柱
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">hanoi</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;请输入盘子数量: &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;汉诺塔移动步骤：&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">hanoi</span><span class="p">(</span><span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="sc">&#39;C&#39;</span><span class="p">,</span> <span class="sc">&#39;B&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="python版本实现">Python版本实现</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="n">from_pole</span><span class="p">,</span> <span class="n">to_pole</span><span class="p">,</span> <span class="n">disk</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;移动单个盘子&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;移动盘子 </span><span class="si">{</span><span class="n">disk</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">from_pole</span><span class="si">}</span><span class="s2"> --&gt; </span><span class="si">{</span><span class="n">to_pole</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">hanoi</span><span class="p">(</span><span class="n">from_pole</span><span class="p">,</span> <span class="n">to_pole</span><span class="p">,</span> <span class="n">aux_pole</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    汉诺塔递归解法
</span></span></span><span class="line"><span class="cl"><span class="s2">    from_pole: 起始柱
</span></span></span><span class="line"><span class="cl"><span class="s2">    to_pole: 目标柱
</span></span></span><span class="line"><span class="cl"><span class="s2">    aux_pole: 辅助柱
</span></span></span><span class="line"><span class="cl"><span class="s2">    n: 盘子数量
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 边界条件：只有一个盘子时，直接移动</span>
</span></span><span class="line"><span class="cl">        <span class="n">move</span><span class="p">(</span><span class="n">from_pole</span><span class="p">,</span> <span class="n">to_pole</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 步骤1：将上面n-1个盘子移动到辅助柱</span>
</span></span><span class="line"><span class="cl">        <span class="n">hanoi</span><span class="p">(</span><span class="n">from_pole</span><span class="p">,</span> <span class="n">aux_pole</span><span class="p">,</span> <span class="n">to_pole</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># 步骤2：移动最大的盘子到目标柱</span>
</span></span><span class="line"><span class="cl">        <span class="n">move</span><span class="p">(</span><span class="n">from_pole</span><span class="p">,</span> <span class="n">to_pole</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># 步骤3：将n-1个盘子从辅助柱移动到目标柱</span>
</span></span><span class="line"><span class="cl">        <span class="n">hanoi</span><span class="p">(</span><span class="n">aux_pole</span><span class="p">,</span> <span class="n">to_pole</span><span class="p">,</span> <span class="n">from_pole</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">count_moves</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;计算移动次数&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">2</span><span class="o">**</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s2">&#34;请输入盘子数量: &#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;</span><span class="se">\n</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">个盘子的汉诺塔移动步骤：&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">hanoi</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;</span><span class="se">\n</span><span class="s2">总移动次数: </span><span class="si">{</span><span class="n">count_moves</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="递归的本质理解">递归的本质理解</h3>
<h4 id="1-递归是一种树形结构">1. 递归是一种树形结构</h4>
<p>递归算法的执行过程可以看作是一棵树：</p>
<ul>
<li>每个节点代表一个子问题</li>
<li>叶子节点是最小的子问题（边界条件）</li>
<li>从根节点到叶子节点的路径就是问题的分解过程</li>
</ul>
<h4 id="2-最小化问题思想">2. 最小化问题思想</h4>
<p>递归的核心是将复杂问题不断分解，直到变成最简单的情况：</p>
<ul>
<li><strong>最小化问题</strong>：只有一个盘子时，直接移动</li>
<li><strong>子问题</strong>：将n个盘子的问题分解为两个n-1个盘子的子问题</li>
<li><strong>组合解</strong>：子问题的解组合起来就是原问题的解</li>
</ul>
<h4 id="3-递归三要素">3. 递归三要素</h4>
<ol>
<li><strong>递归关系</strong>：大问题如何分解为小问题</li>
<li><strong>边界条件</strong>：递归的终止条件</li>
<li><strong>递归假设</strong>：假设子问题已经正确解决</li>
</ol>
<h3 id="汉诺塔的迭代解法">汉诺塔的迭代解法</h3>
<p>除了递归解法，汉诺塔还有基于二进制的迭代解法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">hanoi_iterative</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;汉诺塔的迭代解法&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">total_moves</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 定义柱子</span>
</span></span><span class="line"><span class="cl">    <span class="n">poles</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 根据n的奇偶性确定移动方向</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># n为偶数时，按 A-&gt;B-&gt;C-&gt;A 的顺序</span>
</span></span><span class="line"><span class="cl">        <span class="n">direction</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># n为奇数时，按 A-&gt;C-&gt;B-&gt;A 的顺序</span>
</span></span><span class="line"><span class="cl">        <span class="n">direction</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">total_moves</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 找到二进制表示中最右边的1的位置</span>
</span></span><span class="line"><span class="cl">        <span class="n">disk</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># 确定移动方向</span>
</span></span><span class="line"><span class="cl">        <span class="n">from_pole</span> <span class="o">=</span> <span class="n">poles</span><span class="p">[(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">disk</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">to_pole</span> <span class="o">=</span> <span class="n">poles</span><span class="p">[</span><span class="n">direction</span><span class="p">[(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">disk</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;移动盘子 </span><span class="si">{</span><span class="n">disk</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">from_pole</span><span class="si">}</span><span class="s2"> --&gt; </span><span class="si">{</span><span class="n">to_pole</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;3个盘子的汉诺塔迭代解法：&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">hanoi_iterative</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="分治算法思想">分治算法思想</h2>
<p>分治算法是递归思想的重要应用，它将问题分解为若干个规模较小的同类子问题，递归地解决这些子问题，然后合并结果。</p>
<h3 id="分治算法的基本步骤">分治算法的基本步骤</h3>
<ol>
<li><strong>分解（Divide）</strong>：将原问题分解为若干个规模较小的子问题</li>
<li><strong>解决（Conquer）</strong>：递归地解决各个子问题</li>
<li><strong>合并（Combine）</strong>：将子问题的解合并为原问题的解</li>
</ol>
<h3 id="经典分治算法示例">经典分治算法示例</h3>
<h4 id="归并排序">归并排序</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;归并排序 - 分治算法的经典应用&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">arr</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 分解：将数组分为两半</span>
</span></span><span class="line"><span class="cl">    <span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="n">left</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="n">mid</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="n">right</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">:])</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 合并：将两个有序数组合并</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;合并两个有序数组&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 添加剩余元素</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">:])</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">90</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;原数组: </span><span class="si">{</span><span class="n">arr</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">sorted_arr</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;排序后: </span><span class="si">{</span><span class="n">sorted_arr</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span></code></pre></div><h4 id="快速幂算法">快速幂算法</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">quick_power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exp</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;快速幂算法 - 分治思想的应用&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">exp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">exp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">base</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 分解：将指数分为两半</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">exp</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">half</span> <span class="o">=</span> <span class="n">quick_power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exp</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">half</span> <span class="o">*</span> <span class="n">half</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">base</span> <span class="o">*</span> <span class="n">quick_power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="n">result</span> <span class="o">=</span> <span class="n">quick_power</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;2^10 = </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="递归算法的优化">递归算法的优化</h2>
<h3 id="1-记忆化递归">1. 记忆化递归</h3>
<p>对于有重复子问题的递归，可以使用记忆化来避免重复计算：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">fibonacci_memo</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;带记忆化的斐波那契数列&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">fibonacci_memo</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci_memo</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;fibonacci(40) = </span><span class="si">{</span><span class="n">fibonacci_memo</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="2-尾递归优化">2. 尾递归优化</h3>
<p>尾递归可以被编译器优化为循环：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">factorial_tail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">acc</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;尾递归实现阶乘&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">acc</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">factorial_tail</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">acc</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;5! = </span><span class="si">{</span><span class="n">factorial_tail</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="递归算法的应用场景">递归算法的应用场景</h2>
<ol>
<li><strong>树和图的遍历</strong>：深度优先搜索</li>
<li><strong>分治算法</strong>：归并排序、快速排序</li>
<li><strong>动态规划</strong>：最优子结构问题</li>
<li><strong>回溯算法</strong>：N皇后问题、数独求解</li>
<li><strong>数学计算</strong>：阶乘、斐波那契数列</li>
</ol>
<h2 id="总结">总结</h2>
<p>递归与分治是算法设计中的重要思想：</p>
<h3 id="递归算法的优点">递归算法的优点</h3>
<ul>
<li>代码简洁，逻辑清晰</li>
<li>自然地表达问题的递归结构</li>
<li>易于理解和实现</li>
</ul>
<h3 id="递归算法的缺点">递归算法的缺点</h3>
<ul>
<li>可能存在重复计算</li>
<li>空间复杂度较高（函数调用栈）</li>
<li>可能导致栈溢出</li>
</ul>
<h3 id="使用建议">使用建议</h3>
<ol>
<li>明确递归关系和边界条件</li>
<li>考虑是否存在重复子问题</li>
<li>注意递归深度，避免栈溢出</li>
<li>必要时使用记忆化或改为迭代实现</li>
</ol>
<p>掌握递归与分治思想对于算法学习和问题解决都具有重要意义，它们是许多高级算法的基础。</p>
]]></content:encoded></item></channel></rss>