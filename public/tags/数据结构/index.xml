<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>数据结构 on tyhzxh的个人博客</title>
    <link>http://localhost:1313/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
    <description>Recent content in 数据结构 on tyhzxh的个人博客</description>
    <generator>Hugo -- 0.148.2</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 06 Aug 2025 08:51:21 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>双指针算法详解</title>
      <link>http://localhost:1313/posts/two-pointers-algorithm/</link>
      <pubDate>Thu, 24 Oct 2024 19:52:26 +0800</pubDate>
      <guid>http://localhost:1313/posts/two-pointers-algorithm/</guid>
      <description>深入解析双指针算法的原理、应用场景和实现技巧，包括对撞指针、快慢指针、滑动窗口等经典模式</description>
      <content:encoded><![CDATA[<h2 id="介绍">介绍</h2>
<p>双指针是一种常用的算法技巧，通过使用两个指针来遍历数据结构，可以有效地减少时间复杂度，从O(n²)降低到O(n)。双指针的类型主要有以下几种：</p>
<h3 id="1-对撞指针two-pointers-from-two-sides">1. 对撞指针（Two Pointers from Two Sides）</h3>
<p>两个指针分别从数组或链表的两端开始，向中间移动，直到相遇或者满足某个条件。这种方法适用于有序数组或链表，可以用于查找和问题、乘积和问题等。</p>
<h3 id="2-快慢指针fast-and-slow-pointers">2. 快慢指针（Fast and Slow Pointers）</h3>
<p>两个指针从同一位置开始，一个指针（快指针）移动的速度是另一个指针（慢指针）的两倍。这种方法常用于链表问题，比如判断链表是否有环，或者找到链表的中间节点。</p>
<h3 id="3-左右指针left-and-right-pointers">3. 左右指针（Left and Right Pointers）</h3>
<p>两个指针分别从数组的两端开始，向中间移动。这种方法适用于有序数组，可以用于查找特定元素或者解决三数之和问题。</p>
<h3 id="4-无序指针">4. 无序指针</h3>
<p>如果两个指针没有任何语义和逻辑顺序，只是用于指向不同的地址，也可以直接简单命名。例如，在合并两个有序链表的问题中，可以使用两个无序指针分别指向链表1和链表2。</p>
<h2 id="应用场景">应用场景</h2>
<p>双指针算法的关键在于如何移动这两个指针。双指针技巧通常用于解决涉及数组或链表的问题，它可以帮助我们以线性时间复杂度解决问题，而不是使用嵌套循环导致的时间复杂度为O(n²)。</p>
<h3 id="常见使用场景">常见使用场景：</h3>
<ol>
<li>
<p><strong>滑动窗口问题</strong>：当需要找到一个子数组或子串，使得它满足特定条件（如最大和、最小和、包含特定元素等）时，可以使用双指针来维护一个滑动窗口。</p>
</li>
<li>
<p><strong>有序数组中的查找问题</strong>：如果有两个有序数组，需要找到两个数组的第k小的数，或者判断一个数组是否是另一个数组的子集，可以使用双指针。</p>
</li>
<li>
<p><strong>链表问题</strong>：在链表中找到中间节点、删除链表中的节点、合并两个有序链表等问题，通常使用快慢指针。</p>
</li>
<li>
<p><strong>数组中的成对问题</strong>：需要在数组中找到两个数，它们的和为特定值（如&quot;两数之和&quot;问题），或者需要找到两个数，它们的乘积为特定值。</p>
</li>
<li>
<p><strong>循环数组问题</strong>：当数组是循环的，需要找到重复的元素或者满足特定条件的元素对时，可以使用双指针。</p>
</li>
<li>
<p><strong>数组中的连续子数组问题</strong>：需要找到连续的子数组，使得它们的和满足特定条件，或者找到最长的连续子数组，使得它们满足特定条件。</p>
</li>
</ol>
<h2 id="算法优势">算法优势</h2>
<p>双指针技巧在解决特定问题时具有显著的优势：</p>
<h3 id="1-时间复杂度优化">1. 时间复杂度优化</h3>
<p>双指针可以减少不必要的重复计算，尤其是在处理有序数组或链表时，可以避免使用嵌套循环导致的二次方时间复杂度，通常可以将时间复杂度降低到线性时间复杂度O(n)。</p>
<h3 id="2-空间复杂度优化">2. 空间复杂度优化</h3>
<p>双指针通常只需要常数级别的额外空间，这比使用额外的数据结构（如哈希表）要节省空间。</p>
<h3 id="3-简化问题">3. 简化问题</h3>
<p>双指针可以将复杂问题简化为更简单的形式。例如，在滑动窗口问题中，双指针可以动态地维护一个窗口，而不需要每次都重新计算窗口内的元素。</p>
<h3 id="4-灵活性和适应性">4. 灵活性和适应性</h3>
<p>双指针技巧非常灵活，可以根据问题的不同需求调整指针的移动策略，如可以同时向中间移动，也可以一个向前移动而另一个向后移动。</p>
<h2 id="滑动窗口">滑动窗口</h2>
<p>滑动窗口（Sliding Window）是一种在数组或字符串上进行操作的算法策略，主要用于解决需要在连续子数组或子字符串上满足特定条件的问题。</p>
<h3 id="为什么叫滑动窗口">为什么叫滑动窗口？</h3>
<p>&ldquo;滑动窗口&quot;这个名字的由来是因为这种算法的操作方式类似于一个可以沿着数组或字符串滑动的窗口。窗口可以扩大或缩小，以包含不同的元素，直到找到满足条件的子数组或子字符串。</p>
<h3 id="滑动窗口的特点">滑动窗口的特点：</h3>
<ol>
<li><strong>连续性</strong>：窗口内的元素是连续的，不需要是整个数组或字符串的子集。</li>
<li><strong>动态性</strong>：窗口的大小可以根据需要动态调整，窗口的边界可以向前或向后移动。</li>
<li><strong>实时性</strong>：窗口可以实时地检查当前窗口内的数据是否满足条件。</li>
</ol>
<h3 id="滑动窗口的实现">滑动窗口的实现：</h3>
<p>滑动窗口通常使用双指针（或索引）来实现，一个指针表示窗口的开始，另一个指针表示窗口的结束。通过移动这两个指针，可以动态地调整窗口的大小和位置。</p>
<ul>
<li><strong>扩展窗口</strong>：通常通过移动结束指针（右指针）向右来实现，这样可以包含更多的元素。</li>
<li><strong>收缩窗口</strong>：通常通过移动开始指针（左指针）向右来实现，这样可以排除窗口中的第一个元素。</li>
</ul>
<h2 id="经典算法实现">经典算法实现</h2>
<h3 id="1-对撞指针示例">1. 对撞指针示例</h3>
<p><strong>问题描述</strong>：找出数组中乘积小于K的连续子数组的最大长度。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">maxProductSubarray</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="n">max_length</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="n">product</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">product</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">product</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">product</span> <span class="o">/=</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">        <span class="n">max_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_length</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">right</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">max_length</span>
</span></span></code></pre></div><h3 id="2-快慢指针示例">2. 快慢指针示例</h3>
<p><strong>问题描述</strong>：判断链表是否有环，并返回环的入口节点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ListNode</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">detectCycle</span><span class="p">(</span><span class="n">head</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">slow</span> <span class="o">=</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 第一阶段：检测是否有环</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">fast</span> <span class="ow">and</span> <span class="n">fast</span><span class="o">.</span><span class="n">next</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="n">next</span>
</span></span><span class="line"><span class="cl">        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 第二阶段：找到环的入口</span>
</span></span><span class="line"><span class="cl">    <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="n">next</span>
</span></span><span class="line"><span class="cl">        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="n">next</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">slow</span>
</span></span></code></pre></div><h3 id="3-左右指针示例">3. 左右指针示例</h3>
<p><strong>问题描述</strong>：找出数组中三数之和为0的三元组。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">threeSum</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">nums</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">current_sum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">current_sum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]])</span>
</span></span><span class="line"><span class="cl">                
</span></span><span class="line"><span class="cl">                <span class="c1"># 跳过重复元素</span>
</span></span><span class="line"><span class="cl">                <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                    
</span></span><span class="line"><span class="cl">                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="k">elif</span> <span class="n">current_sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span>
</span></span></code></pre></div><h2 id="总结">总结</h2>
<p>双指针技巧是一种高效且强大的算法工具，适用于解决多种算法问题，特别是在处理数组和链表时。通过合理使用双指针，可以设计出既高效又简洁的算法解决方案。</p>
<p>滑动窗口算法的时间复杂度通常是O(n)，其中n是数组或字符串的长度，这使得它在处理大数据集时非常有效。掌握双指针技巧对于提升算法能力和解决实际编程问题都具有重要意义。</p>
]]></content:encoded>
    </item>
    <item>
      <title>经典排序算法实现与分析</title>
      <link>http://localhost:1313/posts/sorting-algorithms-implementation/</link>
      <pubDate>Tue, 27 Feb 2024 22:11:13 +0800</pubDate>
      <guid>http://localhost:1313/posts/sorting-algorithms-implementation/</guid>
      <description>详细介绍和实现经典排序算法，包括选择排序、插入排序、冒泡排序、快速排序、归并排序和堆排序，并提供性能测试代码</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>这是某次学校数据结构实验中实现的基本排序算法。数据结构这门课的难点在于实现的复杂性，每次实验都需要封装数据结构，编写测试程序，对于初学者来说确实是一个挑战。</p>
<p>通过这次实验，我深刻体会到了代码质量的重要性。虽然当时的代码可能不够优雅，但这正是学习过程中的宝贵经历。</p>
<h2 id="基本数据结构封装">基本数据结构封装</h2>
<p>首先定义基本的数据结构和工具函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;stdio.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define ERROR 0
</span></span></span><span class="line"><span class="cl"><span class="cp">#define OK 1
</span></span></span><span class="line"><span class="cl"><span class="cp">#define Overflow 2
</span></span></span><span class="line"><span class="cl"><span class="cp">#define Underflow 3
</span></span></span><span class="line"><span class="cl"><span class="cp">#define NotPresent 4    </span><span class="c1">// 元素不存在
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define Duplicate 5     </span><span class="c1">// 元素重复存在
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define MaxSize 100001
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">int</span> <span class="n">KeyType</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">int</span> <span class="n">Status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">int</span> <span class="n">DataType</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">Entry</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">KeyType</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">DataType</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">entry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">list</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Entry</span> <span class="n">D</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">List</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 输出函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Status</span> <span class="nf">printlist</span><span class="p">(</span><span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 交换函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">Entry</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">Entry</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Entry</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="排序算法实现">排序算法实现</h2>
<h3 id="1-简单选择排序">1. 简单选择排序</h3>
<p>选择排序的基本思想是每次从未排序的元素中选择最小的元素，放到已排序序列的末尾。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Status</span> <span class="nf">choosesort</span><span class="p">(</span><span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">min</span><span class="p">].</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">min</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">min</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>时间复杂度</strong>：O(n²)<br>
<strong>空间复杂度</strong>：O(1)<br>
<strong>稳定性</strong>：不稳定</p>
<h3 id="2-直接插入排序">2. 直接插入排序</h3>
<p>插入排序的基本思想是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Status</span> <span class="nf">insertsort</span><span class="p">(</span><span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Entry</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">temp</span><span class="p">.</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>时间复杂度</strong>：O(n²)<br>
<strong>空间复杂度</strong>：O(1)<br>
<strong>稳定性</strong>：稳定</p>
<h3 id="3-冒泡排序">3. 冒泡排序</h3>
<p>冒泡排序是一种简单的排序算法，它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">Bubblesort</span><span class="p">(</span><span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">start</span><span class="p">].</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">end</span><span class="p">].</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">Entry</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">end</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>时间复杂度</strong>：O(n²)<br>
<strong>空间复杂度</strong>：O(1)<br>
<strong>稳定性</strong>：稳定</p>
<h3 id="4-快速排序">4. 快速排序</h3>
<p>快速排序使用分治法策略来把一个序列分为较小和较大的2个子序列，然后递归地排序两个子序列。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="n">List</span><span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">high</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Entry</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">low</span><span class="p">];</span> <span class="c1">// 选择第一个元素作为基准
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 从右向左找小于基准的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">.</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">j</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                
</span></span><span class="line"><span class="cl">            <span class="c1">// 从左向右找大于基准的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">.</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pivot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">QuickSort</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>   <span class="c1">// 递归排序左半部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">QuickSort</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span> <span class="c1">// 递归排序右半部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>时间复杂度</strong>：平均O(n log n)，最坏O(n²)<br>
<strong>空间复杂度</strong>：O(log n)<br>
<strong>稳定性</strong>：不稳定</p>
<blockquote>
<p>快速排序确实很精妙，理解和记忆都需要时间。它的核心思想是分治法，通过选择一个基准元素，将数组分为两部分，然后递归地对两部分进行排序。</p></blockquote>
<h3 id="5-归并排序">5. 归并排序</h3>
<p>归并排序采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lmid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rmid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">rmid</span><span class="p">;</span> <span class="c1">// i,j指向left和right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">list</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 合并两个有序序列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">lmid</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">temp</span><span class="p">.</span><span class="n">D</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">temp</span><span class="p">.</span><span class="n">D</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 复制剩余元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">lmid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">temp</span><span class="p">.</span><span class="n">D</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">temp</span><span class="p">.</span><span class="n">D</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 将临时数组的内容复制回原数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Status</span> <span class="nf">mergesort</span><span class="p">(</span><span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">mergesort</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">mergesort</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">merge</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>时间复杂度</strong>：O(n log n)<br>
<strong>空间复杂度</strong>：O(n)<br>
<strong>稳定性</strong>：稳定</p>
<h3 id="6-堆排序">6. 堆排序</h3>
<p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">downadjust</span><span class="p">(</span><span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Entry</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果左子结点小于右子结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span><span class="o">++</span><span class="p">;</span> <span class="c1">// i指向右子结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果父结点大于子结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">key</span> <span class="o">&gt;=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span> <span class="c1">// 调整结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            
</span></span><span class="line"><span class="cl">        <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// 否则将子结点值赋给父结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// 重新赋值开始指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span> <span class="c1">// 调整结束后，将temp值放在最终位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Status</span> <span class="nf">heapsort</span><span class="p">(</span><span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 建堆
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">downadjust</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>时间复杂度</strong>：O(n log n)<br>
<strong>空间复杂度</strong>：O(1)<br>
<strong>稳定性</strong>：不稳定</p>
<h2 id="测试框架">测试框架</h2>
<h3 id="数据初始化">数据初始化</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">list</span><span class="o">*</span> <span class="nf">initlist</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">list</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">list</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">MaxSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span> <span class="c1">// 生成随机种子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 随机数赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">50</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">deletelist</span><span class="p">(</span><span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">l</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">free</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="性能测试函数">性能测试函数</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Status</span> <span class="nf">testchoosesort</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">list</span><span class="o">*</span> <span class="n">l0</span> <span class="o">=</span> <span class="n">initlist</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n\n</span><span class="s">make a new list!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printlist</span><span class="p">(</span><span class="n">l0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">clock_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">finish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">start</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">choosesort</span><span class="p">(</span><span class="n">l0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">finish</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">after choosesort</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printlist</span><span class="p">(</span><span class="n">l0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">TheTimes</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">finish</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;消耗%f秒。</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">TheTimes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">deletelist</span><span class="p">(</span><span class="n">l0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Status</span> <span class="nf">testquicksort</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">list</span><span class="o">*</span> <span class="n">l0</span> <span class="o">=</span> <span class="n">initlist</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n\n</span><span class="s">make a new list!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printlist</span><span class="p">(</span><span class="n">l0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">clock_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">finish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">start</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">QuickSort</span><span class="p">(</span><span class="n">l0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l0</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">finish</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">after quicksort</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printlist</span><span class="p">(</span><span class="n">l0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">TheTimes</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">finish</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;消耗%f秒。</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">TheTimes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">deletelist</span><span class="p">(</span><span class="n">l0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 主测试函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;测试不同规模数据的排序性能：</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">testinsertsort</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">testchoosesort</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">testBubblesort</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">testquicksort</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">testmergesort</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="算法性能比较">算法性能比较</h2>
<table>
  <thead>
      <tr>
          <th>排序算法</th>
          <th>平均时间复杂度</th>
          <th>最坏时间复杂度</th>
          <th>最好时间复杂度</th>
          <th>空间复杂度</th>
          <th>稳定性</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>选择排序</td>
          <td>O(n²)</td>
          <td>O(n²)</td>
          <td>O(n²)</td>
          <td>O(1)</td>
          <td>不稳定</td>
      </tr>
      <tr>
          <td>插入排序</td>
          <td>O(n²)</td>
          <td>O(n²)</td>
          <td>O(n)</td>
          <td>O(1)</td>
          <td>稳定</td>
      </tr>
      <tr>
          <td>冒泡排序</td>
          <td>O(n²)</td>
          <td>O(n²)</td>
          <td>O(n)</td>
          <td>O(1)</td>
          <td>稳定</td>
      </tr>
      <tr>
          <td>快速排序</td>
          <td>O(n log n)</td>
          <td>O(n²)</td>
          <td>O(n log n)</td>
          <td>O(log n)</td>
          <td>不稳定</td>
      </tr>
      <tr>
          <td>归并排序</td>
          <td>O(n log n)</td>
          <td>O(n log n)</td>
          <td>O(n log n)</td>
          <td>O(n)</td>
          <td>稳定</td>
      </tr>
      <tr>
          <td>堆排序</td>
          <td>O(n log n)</td>
          <td>O(n log n)</td>
          <td>O(n log n)</td>
          <td>O(1)</td>
          <td>不稳定</td>
      </tr>
  </tbody>
</table>
<h2 id="总结">总结</h2>
<p>通过这次排序算法的实现和测试，我们可以得出以下结论：</p>
<ol>
<li>
<p><strong>简单排序算法</strong>（选择、插入、冒泡）实现简单，但时间复杂度较高，适合小规模数据。</p>
</li>
<li>
<p><strong>高效排序算法</strong>（快速、归并、堆）时间复杂度较低，适合大规模数据处理。</p>
</li>
<li>
<p><strong>稳定性</strong>在某些应用场景中很重要，需要根据具体需求选择合适的算法。</p>
</li>
<li>
<p><strong>空间复杂度</strong>也是选择算法时需要考虑的重要因素。</p>
</li>
</ol>
<p>学习排序算法不仅仅是为了应付考试，更重要的是理解算法设计的思想和优化策略。每种算法都有其适用的场景，在实际开发中需要根据具体情况选择最合适的算法。</p>
<blockquote>
<p>代码质量的提升确实需要大量的练习和思考。虽然当时的代码可能不够完美，但这正是成长过程中的重要一步。</p></blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>贪心算法详解：从基础概念到经典问题</title>
      <link>http://localhost:1313/posts/greedy-algorithm-guide/</link>
      <pubDate>Tue, 27 Feb 2024 22:02:23 +0800</pubDate>
      <guid>http://localhost:1313/posts/greedy-algorithm-guide/</guid>
      <description>深入解析贪心算法的核心思想、设计原则和应用场景，通过经典问题实例掌握贪心策略的选择和证明方法，包括活动选择、背包问题、最短路径等</description>
      <content:encoded><![CDATA[<h2 id="贪心算法概述">贪心算法概述</h2>
<p>**贪心算法（Greedy Algorithm）**是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。贪心算法在算法竞赛和实际工程中都有着重要的地位。</p>
<h2 id="贪心算法的核心思想">贪心算法的核心思想</h2>
<h3 id="基本原理">基本原理</h3>
<p>贪心算法的核心思想是：</p>
<ol>
<li><strong>局部最优选择</strong>：在每一步都做出当前看起来最优的选择</li>
<li><strong>不回溯</strong>：一旦做出选择，就不再改变</li>
<li><strong>希望全局最优</strong>：通过局部最优选择达到全局最优解</li>
</ol>
<h3 id="贪心选择性质">贪心选择性质</h3>
<p>一个问题能够用贪心算法解决，必须具备以下性质：</p>
<table>
  <thead>
      <tr>
          <th>性质</th>
          <th>描述</th>
          <th>重要性</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>贪心选择性质</strong></td>
          <td>通过局部最优选择能达到全局最优</td>
          <td>核心性质</td>
      </tr>
      <tr>
          <td><strong>最优子结构</strong></td>
          <td>问题的最优解包含子问题的最优解</td>
          <td>必要条件</td>
      </tr>
      <tr>
          <td><strong>无后效性</strong></td>
          <td>当前选择不影响之前的选择</td>
          <td>保证正确性</td>
      </tr>
  </tbody>
</table>
<h2 id="贪心算法设计步骤">贪心算法设计步骤</h2>
<h3 id="1-问题分析">1. 问题分析</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">greedy_algorithm_template</span><span class="p">(</span><span class="n">problem_input</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    贪心算法通用模板
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 步骤1：将问题分解为子问题</span>
</span></span><span class="line"><span class="cl">    <span class="n">subproblems</span> <span class="o">=</span> <span class="n">decompose_problem</span><span class="p">(</span><span class="n">problem_input</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 步骤2：确定贪心策略</span>
</span></span><span class="line"><span class="cl">    <span class="n">strategy</span> <span class="o">=</span> <span class="n">define_greedy_strategy</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 步骤3：按贪心策略排序</span>
</span></span><span class="line"><span class="cl">    <span class="n">sorted_items</span> <span class="o">=</span> <span class="n">sort_by_strategy</span><span class="p">(</span><span class="n">subproblems</span><span class="p">,</span> <span class="n">strategy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 步骤4：逐步构造解</span>
</span></span><span class="line"><span class="cl">    <span class="n">solution</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sorted_items</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">is_feasible</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">solution</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">solution</span>
</span></span></code></pre></div><h3 id="2-贪心策略选择">2. 贪心策略选择</h3>
<p>常见的贪心策略包括：</p>
<table>
  <thead>
      <tr>
          <th>策略类型</th>
          <th>描述</th>
          <th>适用场景</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>最大优先</strong></td>
          <td>优先选择最大值</td>
          <td>最大收益问题</td>
      </tr>
      <tr>
          <td><strong>最小优先</strong></td>
          <td>优先选择最小值</td>
          <td>最小成本问题</td>
      </tr>
      <tr>
          <td><strong>比值优先</strong></td>
          <td>按某种比值排序</td>
          <td>效率优化问题</td>
      </tr>
      <tr>
          <td><strong>截止时间优先</strong></td>
          <td>按时间排序</td>
          <td>调度问题</td>
      </tr>
  </tbody>
</table>
<h2 id="经典贪心算法问题">经典贪心算法问题</h2>
<h3 id="1-活动选择问题">1. 活动选择问题</h3>
<h4 id="问题描述">问题描述</h4>
<p>给定n个活动，每个活动都有开始时间和结束时间，选择最多的活动使得它们不冲突。</p>
<h4 id="贪心策略">贪心策略</h4>
<p><strong>按结束时间排序，优先选择结束时间最早的活动</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">activity_selection</span><span class="p">(</span><span class="n">activities</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    活动选择问题 - 贪心算法
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Args:
</span></span></span><span class="line"><span class="cl"><span class="s2">        activities: [(start_time, end_time, activity_id), ...]
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns:
</span></span></span><span class="line"><span class="cl"><span class="s2">        selected_activities: 选中的活动列表
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 按结束时间排序</span>
</span></span><span class="line"><span class="cl">    <span class="n">activities</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">selected</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_end_time</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">activity_id</span> <span class="ow">in</span> <span class="n">activities</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 如果当前活动的开始时间 &gt;= 上一个活动的结束时间</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">last_end_time</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">selected</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">activity_id</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="n">last_end_time</span> <span class="o">=</span> <span class="n">end</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">selected</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="n">activities</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">),</span>   <span class="c1"># 活动A: 1-4</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span>   <span class="c1"># 活动B: 3-5</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">),</span>   <span class="c1"># 活动C: 0-6</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">),</span>   <span class="c1"># 活动D: 5-7</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">),</span>   <span class="c1"># 活动E: 3-9</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">),</span>   <span class="c1"># 活动F: 5-9</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">),</span>  <span class="c1"># 活动G: 6-10</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">),</span>  <span class="c1"># 活动H: 8-11</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">),</span>  <span class="c1"># 活动I: 8-12</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">),</span>  <span class="c1"># 活动J: 2-14</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">)</span>  <span class="c1"># 活动K: 12-16</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">result</span> <span class="o">=</span> <span class="n">activity_selection</span><span class="p">(</span><span class="n">activities</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;选中的活动:&#34;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 输出: [(1, 4, &#39;A&#39;), (5, 7, &#39;D&#39;), (8, 11, &#39;H&#39;), (12, 16, &#39;K&#39;)]</span>
</span></span></code></pre></div><h4 id="正确性证明">正确性证明</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">prove_activity_selection</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    活动选择问题正确性证明思路：
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    1. 贪心选择性质：
</span></span></span><span class="line"><span class="cl"><span class="s2">       - 设最优解为OPT，贪心解为GREEDY
</span></span></span><span class="line"><span class="cl"><span class="s2">       - 如果OPT的第一个活动不是最早结束的，
</span></span></span><span class="line"><span class="cl"><span class="s2">         可以替换为最早结束的活动，不会使解变差
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    2. 最优子结构：
</span></span></span><span class="line"><span class="cl"><span class="s2">       - 选择第一个活动后，剩余问题仍是活动选择问题
</span></span></span><span class="line"><span class="cl"><span class="s2">       - 原问题的最优解 = 第一个活动 + 子问题的最优解
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">pass</span>
</span></span></code></pre></div><h3 id="2-分数背包问题">2. 分数背包问题</h3>
<h4 id="问题描述-1">问题描述</h4>
<p>有一个容量为W的背包和n个物品，每个物品有重量和价值，可以取物品的一部分，求最大价值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">fractional_knapsack</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">capacity</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    分数背包问题 - 贪心算法
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Args:
</span></span></span><span class="line"><span class="cl"><span class="s2">        items: [(weight, value, item_id), ...]
</span></span></span><span class="line"><span class="cl"><span class="s2">        capacity: 背包容量
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns:
</span></span></span><span class="line"><span class="cl"><span class="s2">        (max_value, selected_items): 最大价值和选中的物品
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 按价值密度（价值/重量）降序排序</span>
</span></span><span class="line"><span class="cl">    <span class="n">items</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">total_value</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="n">selected_items</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">remaining_capacity</span> <span class="o">=</span> <span class="n">capacity</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">weight</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">item_id</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">remaining_capacity</span> <span class="o">&gt;=</span> <span class="n">weight</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 完全装入</span>
</span></span><span class="line"><span class="cl">            <span class="n">selected_items</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">weight</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">item_id</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="n">total_value</span> <span class="o">+=</span> <span class="n">value</span>
</span></span><span class="line"><span class="cl">            <span class="n">remaining_capacity</span> <span class="o">-=</span> <span class="n">weight</span>
</span></span><span class="line"><span class="cl">        <span class="k">elif</span> <span class="n">remaining_capacity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 部分装入</span>
</span></span><span class="line"><span class="cl">            <span class="n">fraction</span> <span class="o">=</span> <span class="n">remaining_capacity</span> <span class="o">/</span> <span class="n">weight</span>
</span></span><span class="line"><span class="cl">            <span class="n">selected_items</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">weight</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">item_id</span><span class="p">,</span> <span class="n">fraction</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="n">total_value</span> <span class="o">+=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">fraction</span>
</span></span><span class="line"><span class="cl">            <span class="n">remaining_capacity</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">total_value</span><span class="p">,</span> <span class="n">selected_items</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="n">items</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">),</span>   <span class="c1"># 物品A: 重量10, 价值60, 密度6.0</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span>  <span class="c1"># 物品B: 重量20, 价值100, 密度5.0</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">)</span>   <span class="c1"># 物品C: 重量30, 价值120, 密度4.0</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">max_value</span><span class="p">,</span> <span class="n">selected</span> <span class="o">=</span> <span class="n">fractional_knapsack</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;最大价值: </span><span class="si">{</span><span class="n">max_value</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;选中的物品:&#34;</span><span class="p">,</span> <span class="n">selected</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 输出: 最大价值: 240.0</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 选中的物品: [(10, 60, &#39;A&#39;, 1.0), (20, 100, &#39;B&#39;, 1.0), (30, 120, &#39;C&#39;, 0.6667)]</span>
</span></span></code></pre></div><h3 id="3-哈夫曼编码">3. 哈夫曼编码</h3>
<h4 id="问题描述-2">问题描述</h4>
<p>给定字符频率，构造最优前缀编码，使得编码总长度最小。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">heapq</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">Counter</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">HuffmanNode</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">char</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">char</span> <span class="o">=</span> <span class="n">char</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">freq</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">huffman_encoding</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    哈夫曼编码 - 贪心算法
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Args:
</span></span></span><span class="line"><span class="cl"><span class="s2">        text: 输入文本
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns:
</span></span></span><span class="line"><span class="cl"><span class="s2">        (encoded_text, huffman_tree, codes): 编码结果、哈夫曼树、编码表
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 统计字符频率</span>
</span></span><span class="line"><span class="cl">    <span class="n">freq_map</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 创建优先队列（最小堆）</span>
</span></span><span class="line"><span class="cl">    <span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">char</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">freq_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">HuffmanNode</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="n">freq</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 构建哈夫曼树</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 取出频率最小的两个节点</span>
</span></span><span class="line"><span class="cl">        <span class="n">left</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">right</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># 创建新的内部节点</span>
</span></span><span class="line"><span class="cl">        <span class="n">merged</span> <span class="o">=</span> <span class="n">HuffmanNode</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">freq</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">freq</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">right</span><span class="o">=</span><span class="n">right</span>
</span></span><span class="line"><span class="cl">        <span class="p">)</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">merged</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 根节点</span>
</span></span><span class="line"><span class="cl">    <span class="n">root</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">heap</span> <span class="k">else</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 生成编码表</span>
</span></span><span class="line"><span class="cl">    <span class="n">codes</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">generate_codes</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="s2">&#34;&#34;</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">char</span><span class="p">:</span>  <span class="c1"># 叶子节点</span>
</span></span><span class="line"><span class="cl">                <span class="n">codes</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span> <span class="k">if</span> <span class="n">code</span> <span class="k">else</span> <span class="s2">&#34;0&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">:</span>  <span class="c1"># 内部节点</span>
</span></span><span class="line"><span class="cl">                <span class="n">generate_codes</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">code</span> <span class="o">+</span> <span class="s2">&#34;0&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">generate_codes</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">code</span> <span class="o">+</span> <span class="s2">&#34;1&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">generate_codes</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 编码文本</span>
</span></span><span class="line"><span class="cl">    <span class="n">encoded_text</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">text</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">encoded_text</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">codes</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="n">text</span> <span class="o">=</span> <span class="s2">&#34;ABRACADABRA&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">encoded</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">codes</span> <span class="o">=</span> <span class="n">huffman_encoding</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;原文本:&#34;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;字符编码:&#34;</span><span class="p">,</span> <span class="n">codes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;编码结果:&#34;</span><span class="p">,</span> <span class="n">encoded</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;压缩率: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span><span class="si">:</span><span class="s2">.2%</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 解码函数</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">huffman_decoding</span><span class="p">(</span><span class="n">encoded_text</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;哈夫曼解码&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="s2">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">decoded</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">current</span> <span class="o">=</span> <span class="n">root</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">encoded_text</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">bit</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">right</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">char</span><span class="p">:</span>  <span class="c1"># 到达叶子节点</span>
</span></span><span class="line"><span class="cl">            <span class="n">decoded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="o">.</span><span class="n">char</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">current</span> <span class="o">=</span> <span class="n">root</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s2">&#34;&#34;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">decoded</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">decoded</span> <span class="o">=</span> <span class="n">huffman_decoding</span><span class="p">(</span><span class="n">encoded</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;解码结果:&#34;</span><span class="p">,</span> <span class="n">decoded</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="4-最小生成树kruskal算法">4. 最小生成树（Kruskal算法）</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">UnionFind</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;并查集数据结构&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">px</span> <span class="o">==</span> <span class="n">py</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">False</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">px</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">py</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="o">=</span> <span class="n">py</span><span class="p">,</span> <span class="n">px</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">py</span><span class="p">]</span> <span class="o">=</span> <span class="n">px</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">px</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">py</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">px</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">True</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">kruskal_mst</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    Kruskal最小生成树算法 - 贪心算法
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Args:
</span></span></span><span class="line"><span class="cl"><span class="s2">        n: 顶点数量
</span></span></span><span class="line"><span class="cl"><span class="s2">        edges: [(weight, u, v), ...] 边的列表
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns:
</span></span></span><span class="line"><span class="cl"><span class="s2">        (mst_weight, mst_edges): 最小生成树的权重和边
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 按权重排序</span>
</span></span><span class="line"><span class="cl">    <span class="n">edges</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">uf</span> <span class="o">=</span> <span class="n">UnionFind</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">mst_edges</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">mst_weight</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">weight</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">uf</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>  <span class="c1"># 如果不形成环</span>
</span></span><span class="line"><span class="cl">            <span class="n">mst_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">weight</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="n">mst_weight</span> <span class="o">+=</span> <span class="n">weight</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mst_edges</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># 生成树完成</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">mst_weight</span><span class="p">,</span> <span class="n">mst_edges</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="n">edges</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>   <span class="c1"># 边 0-1，权重1</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>   <span class="c1"># 边 0-2，权重2</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>   <span class="c1"># 边 1-2，权重3</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>   <span class="c1"># 边 1-3，权重4</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>   <span class="c1"># 边 2-3，权重5</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">weight</span><span class="p">,</span> <span class="n">mst</span> <span class="o">=</span> <span class="n">kruskal_mst</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;最小生成树权重: </span><span class="si">{</span><span class="n">weight</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;最小生成树边:&#34;</span><span class="p">,</span> <span class="n">mst</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="5-区间调度问题">5. 区间调度问题</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">interval_scheduling</span><span class="p">(</span><span class="n">intervals</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    区间调度问题 - 贪心算法
</span></span></span><span class="line"><span class="cl"><span class="s2">    选择最多的不重叠区间
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Args:
</span></span></span><span class="line"><span class="cl"><span class="s2">        intervals: [(start, end, interval_id), ...]
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns:
</span></span></span><span class="line"><span class="cl"><span class="s2">        selected_intervals: 选中的区间列表
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 按结束时间排序</span>
</span></span><span class="line"><span class="cl">    <span class="n">intervals</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">selected</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_end</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">interval_id</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">last_end</span><span class="p">:</span>  <span class="c1"># 不重叠</span>
</span></span><span class="line"><span class="cl">            <span class="n">selected</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">interval_id</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="n">last_end</span> <span class="o">=</span> <span class="n">end</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">selected</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">interval_coloring</span><span class="p">(</span><span class="n">intervals</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    区间着色问题 - 贪心算法
</span></span></span><span class="line"><span class="cl"><span class="s2">    用最少的颜色给所有区间着色，使得重叠区间颜色不同
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Args:
</span></span></span><span class="line"><span class="cl"><span class="s2">        intervals: [(start, end, interval_id), ...]
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns:
</span></span></span><span class="line"><span class="cl"><span class="s2">        coloring: {interval_id: color}
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 按开始时间排序</span>
</span></span><span class="line"><span class="cl">    <span class="n">intervals</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">coloring</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">color_end_times</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 每种颜色的最后结束时间</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">interval_id</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 找到可以复用的颜色</span>
</span></span><span class="line"><span class="cl">        <span class="n">color</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">end_time</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">color_end_times</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end_time</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">color</span> <span class="o">=</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">color</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># 需要新颜色</span>
</span></span><span class="line"><span class="cl">            <span class="n">color</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">color_end_times</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">color_end_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>  <span class="c1"># 复用颜色</span>
</span></span><span class="line"><span class="cl">            <span class="n">color_end_times</span><span class="p">[</span><span class="n">color</span><span class="p">]</span> <span class="o">=</span> <span class="n">end</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">coloring</span><span class="p">[</span><span class="n">interval_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">coloring</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">color_end_times</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="n">intervals</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 区间调度</span>
</span></span><span class="line"><span class="cl"><span class="n">selected</span> <span class="o">=</span> <span class="n">interval_scheduling</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;选中的区间:&#34;</span><span class="p">,</span> <span class="n">selected</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 区间着色</span>
</span></span><span class="line"><span class="cl"><span class="n">coloring</span><span class="p">,</span> <span class="n">num_colors</span> <span class="o">=</span> <span class="n">interval_coloring</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;着色方案:&#34;</span><span class="p">,</span> <span class="n">coloring</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;需要颜色数:&#34;</span><span class="p">,</span> <span class="n">num_colors</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="贪心算法的应用场景">贪心算法的应用场景</h2>
<h3 id="1-调度问题">1. 调度问题</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">job_scheduling_with_deadlines</span><span class="p">(</span><span class="n">jobs</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    带截止时间的作业调度 - 贪心算法
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Args:
</span></span></span><span class="line"><span class="cl"><span class="s2">        jobs: [(profit, deadline, job_id), ...]
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns:
</span></span></span><span class="line"><span class="cl"><span class="s2">        (max_profit, scheduled_jobs): 最大利润和调度的作业
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 按利润降序排序</span>
</span></span><span class="line"><span class="cl">    <span class="n">jobs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 找到最大截止时间</span>
</span></span><span class="line"><span class="cl">    <span class="n">max_deadline</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">job</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 时间槽数组，-1表示空闲</span>
</span></span><span class="line"><span class="cl">    <span class="n">time_slots</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">max_deadline</span>
</span></span><span class="line"><span class="cl">    <span class="n">scheduled_jobs</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">total_profit</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">profit</span><span class="p">,</span> <span class="n">deadline</span><span class="p">,</span> <span class="n">job_id</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 从截止时间往前找空闲时间槽</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">deadline</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_deadline</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">time_slots</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">time_slots</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">job_id</span>
</span></span><span class="line"><span class="cl">                <span class="n">scheduled_jobs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">profit</span><span class="p">,</span> <span class="n">deadline</span><span class="p">,</span> <span class="n">job_id</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="n">total_profit</span> <span class="o">+=</span> <span class="n">profit</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">total_profit</span><span class="p">,</span> <span class="n">scheduled_jobs</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="n">jobs</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;J1&#39;</span><span class="p">),</span>  <span class="c1"># 作业J1: 利润100, 截止时间2</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;J2&#39;</span><span class="p">),</span>   <span class="c1"># 作业J2: 利润10, 截止时间1</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;J3&#39;</span><span class="p">),</span>   <span class="c1"># 作业J3: 利润15, 截止时间2</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="mi">27</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;J4&#39;</span><span class="p">),</span>   <span class="c1"># 作业J4: 利润27, 截止时间1</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">profit</span><span class="p">,</span> <span class="n">scheduled</span> <span class="o">=</span> <span class="n">job_scheduling_with_deadlines</span><span class="p">(</span><span class="n">jobs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;最大利润: </span><span class="si">{</span><span class="n">profit</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;调度的作业:&#34;</span><span class="p">,</span> <span class="n">scheduled</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="2-图论问题">2. 图论问题</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">dijkstra_shortest_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    Dijkstra最短路径算法 - 贪心算法
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Args:
</span></span></span><span class="line"><span class="cl"><span class="s2">        graph: {node: [(neighbor, weight), ...]}
</span></span></span><span class="line"><span class="cl"><span class="s2">        start: 起始节点
</span></span></span><span class="line"><span class="cl"><span class="s2">    
</span></span></span><span class="line"><span class="cl"><span class="s2">    Returns:
</span></span></span><span class="line"><span class="cl"><span class="s2">        distances: {node: shortest_distance}
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="kn">import</span> <span class="nn">heapq</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">distances</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">distances</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 优先队列：(distance, node)</span>
</span></span><span class="line"><span class="cl">    <span class="n">pq</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">pq</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">current_dist</span><span class="p">,</span> <span class="n">current_node</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">pq</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">current_node</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">current_node</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># 更新邻居节点的距离</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">current_node</span><span class="p">,</span> <span class="p">[]):</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">new_dist</span> <span class="o">=</span> <span class="n">current_dist</span> <span class="o">+</span> <span class="n">weight</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">new_dist</span> <span class="o">&lt;</span> <span class="n">distances</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">distances</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_dist</span>
</span></span><span class="line"><span class="cl">                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">pq</span><span class="p">,</span> <span class="p">(</span><span class="n">new_dist</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">distances</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)],</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)],</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">distances</span> <span class="o">=</span> <span class="n">dijkstra_shortest_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;从A到各点的最短距离:&#34;</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="贪心算法的局限性">贪心算法的局限性</h2>
<h3 id="1-不适用的问题">1. 不适用的问题</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">knapsack_01_counterexample</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    0-1背包问题：贪心算法不能得到最优解
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 物品: (重量, 价值)</span>
</span></span><span class="line"><span class="cl">    <span class="n">items</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">120</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">    <span class="n">capacity</span> <span class="o">=</span> <span class="mi">50</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 贪心策略：按价值密度排序</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 密度: [6.0, 5.0, 4.0]</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 贪心选择: 物品1(10,60) + 物品2(20,100) = 价值160</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 最优解: 物品2(20,100) + 物品3(30,120) = 价值220</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;贪心算法不适用于0-1背包问题&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;贪心解: 160, 最优解: 220&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">coin_change_counterexample</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    硬币找零问题：某些币值系统下贪心算法不能得到最优解
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 币值系统: [1, 3, 4]</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 目标金额: 6</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 贪心策略：优先使用大面额</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 贪心解: 4 + 1 + 1 = 3枚硬币</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 最优解: 3 + 3 = 2枚硬币</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;某些币值系统下，贪心算法不能得到最优解&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;贪心解: 3枚硬币, 最优解: 2枚硬币&#34;</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="2-贪心算法的适用条件">2. 贪心算法的适用条件</h3>
<table>
  <thead>
      <tr>
          <th>条件</th>
          <th>说明</th>
          <th>检验方法</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>贪心选择性质</strong></td>
          <td>局部最优能导致全局最优</td>
          <td>数学证明或反证法</td>
      </tr>
      <tr>
          <td><strong>最优子结构</strong></td>
          <td>子问题的最优解构成原问题的最优解</td>
          <td>递归分析</td>
      </tr>
      <tr>
          <td><strong>无后效性</strong></td>
          <td>当前选择不影响之前的选择</td>
          <td>状态分析</td>
      </tr>
  </tbody>
</table>
<h2 id="贪心算法设计技巧">贪心算法设计技巧</h2>
<h3 id="1-策略选择指南">1. 策略选择指南</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">strategy_selection_guide</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    贪心策略选择指南
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">strategies</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;最早截止时间优先&#34;</span><span class="p">:</span> <span class="s2">&#34;调度问题，避免错过截止时间&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;最短处理时间优先&#34;</span><span class="p">:</span> <span class="s2">&#34;最小化平均等待时间&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;最高价值密度优先&#34;</span><span class="p">:</span> <span class="s2">&#34;背包类问题，最大化单位收益&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;最小权重优先&#34;</span><span class="p">:</span> <span class="s2">&#34;生成树问题，最小化总成本&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;最大利润优先&#34;</span><span class="p">:</span> <span class="s2">&#34;选择问题，最大化总收益&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">application</span> <span class="ow">in</span> <span class="n">strategies</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;</span><span class="si">{</span><span class="n">strategy</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">application</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="2-正确性证明方法">2. 正确性证明方法</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">greedy_proof_methods</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    贪心算法正确性证明方法
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">methods</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;交换论证&#34;</span><span class="p">:</span> <span class="s2">&#34;证明贪心选择可以替换最优解中的选择&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;归纳法&#34;</span><span class="p">:</span> <span class="s2">&#34;证明每一步贪心选择都保持最优性&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;反证法&#34;</span><span class="p">:</span> <span class="s2">&#34;假设贪心解不是最优解，推出矛盾&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;切割粘贴&#34;</span><span class="p">:</span> <span class="s2">&#34;将最优解分割重组，证明贪心解不差&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">description</span> <span class="ow">in</span> <span class="n">methods</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">description</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="实际应用案例">实际应用案例</h2>
<h3 id="1-任务调度系统">1. 任务调度系统</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TaskScheduler</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;基于贪心算法的任务调度器&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">add_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task_id</span><span class="p">,</span> <span class="n">priority</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">deadline</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34;添加任务&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="n">task_id</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;priority&#39;</span><span class="p">:</span> <span class="n">priority</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;duration&#39;</span><span class="p">:</span> <span class="n">duration</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;deadline&#39;</span><span class="p">:</span> <span class="n">deadline</span>
</span></span><span class="line"><span class="cl">        <span class="p">})</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">schedule_by_priority</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34;按优先级调度&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;priority&#39;</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">schedule_by_deadline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34;按截止时间调度&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;deadline&#39;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">schedule_by_shortest_job_first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34;最短作业优先调度&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;duration&#39;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="n">scheduler</span> <span class="o">=</span> <span class="n">TaskScheduler</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">scheduler</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span><span class="s1">&#39;T1&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">scheduler</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span><span class="s1">&#39;T2&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">scheduler</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span><span class="s1">&#39;T3&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;按优先级调度:&#34;</span><span class="p">,</span> <span class="n">scheduler</span><span class="o">.</span><span class="n">schedule_by_priority</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;按截止时间调度:&#34;</span><span class="p">,</span> <span class="n">scheduler</span><span class="o">.</span><span class="n">schedule_by_deadline</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;最短作业优先:&#34;</span><span class="p">,</span> <span class="n">scheduler</span><span class="o">.</span><span class="n">schedule_by_shortest_job_first</span><span class="p">())</span>
</span></span></code></pre></div><h3 id="2-缓存替换算法">2. 缓存替换算法</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;基于贪心思想的LRU缓存&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">access_order</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34;获取缓存值&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 更新访问顺序（贪心策略：最近使用的放在最后）</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">access_order</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">access_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;&#34;&#34;设置缓存值&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 更新现有键</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">access_order</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">access_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 添加新键</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">capacity</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># 贪心策略：移除最久未使用的键</span>
</span></span><span class="line"><span class="cl">                <span class="n">lru_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">access_order</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">lru_key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">access_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="n">cache</span> <span class="o">=</span> <span class="n">LRUCache</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">cache</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">cache</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">cache</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;缓存状态:&#34;</span><span class="p">,</span> <span class="n">cache</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>  <span class="c1"># 访问A</span>
</span></span><span class="line"><span class="cl"><span class="n">cache</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># 添加D，应该移除B</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;添加D后:&#34;</span><span class="p">,</span> <span class="n">cache</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="学习建议和总结">学习建议和总结</h2>
<h3 id="学习路径">学习路径</h3>
<ol>
<li><strong>理解核心概念</strong>：掌握贪心选择性质和最优子结构</li>
<li><strong>练习经典问题</strong>：活动选择、背包问题、最短路径等</li>
<li><strong>学会证明方法</strong>：交换论证、归纳法、反证法</li>
<li><strong>识别适用场景</strong>：判断问题是否适合贪心算法</li>
<li><strong>实际应用练习</strong>：调度、优化、图论等实际问题</li>
</ol>
<h3 id="关键要点">关键要点</h3>
<table>
  <thead>
      <tr>
          <th>要点</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>策略选择</strong></td>
          <td>正确的贪心策略是算法成功的关键</td>
      </tr>
      <tr>
          <td><strong>正确性证明</strong></td>
          <td>必须证明贪心选择能得到最优解</td>
      </tr>
      <tr>
          <td><strong>适用性判断</strong></td>
          <td>不是所有问题都适合贪心算法</td>
      </tr>
      <tr>
          <td><strong>效率优势</strong></td>
          <td>贪心算法通常具有较低的时间复杂度</td>
      </tr>
  </tbody>
</table>
<h3 id="常见误区">常见误区</h3>
<ol>
<li><strong>盲目应用</strong>：不验证贪心选择性质就使用贪心算法</li>
<li><strong>策略错误</strong>：选择了错误的贪心策略</li>
<li><strong>忽略证明</strong>：没有证明算法的正确性</li>
<li><strong>适用范围</strong>：将贪心算法应用到不适合的问题上</li>
</ol>
<p>贪心算法是算法设计中的重要思想，虽然不能解决所有优化问题，但在适用的场景下能够提供简洁高效的解决方案。掌握贪心算法的关键在于理解其适用条件，选择正确的贪心策略，并能够证明算法的正确性。</p>
]]></content:encoded>
    </item>
    <item>
      <title>前缀和算法详解与应用</title>
      <link>http://localhost:1313/posts/prefix-sum-algorithm/</link>
      <pubDate>Fri, 23 Feb 2024 13:34:50 +0800</pubDate>
      <guid>http://localhost:1313/posts/prefix-sum-algorithm/</guid>
      <description>深入讲解前缀和算法的原理和应用，包括累计值前缀数组、累计出现次数前缀数组、累积最大值前缀数组等多种变体</description>
      <content:encoded><![CDATA[<h2 id="前缀和算法概述">前缀和算法概述</h2>
<p>前缀和是一种重要的算法技巧，主要用于快速计算数组区间内的各种统计信息。通过预处理构建前缀数组，可以将原本需要O(n)时间复杂度的区间查询优化到O(1)。</p>
<p>前缀和算法的核心思想是：<strong>利用前面已经计算过的结果来快速得出当前的结果</strong>。</p>
<h2 id="前缀和的基本类型">前缀和的基本类型</h2>
<h3 id="1-累计值前缀数组用于区间求和">1. 累计值前缀数组（用于区间求和）</h3>
<p>这是最常见的前缀和应用，用于快速计算数组中任意区间的元素和。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">build_prefix_sum</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;构建前缀和数组&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">prefix_sum</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># 初始化前缀和数组，第一个元素为0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">prefix_sum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prefix_sum</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">num</span><span class="p">)</span>  <span class="c1"># 将当前元素加到前一个前缀和上</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">prefix_sum</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">range_sum</span><span class="p">(</span><span class="n">prefix_sum</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;计算区间和&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">prefix_sum</span><span class="p">[</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">prefix_sum</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">prefix_sum</span> <span class="o">=</span> <span class="n">build_prefix_sum</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;原数组: </span><span class="si">{</span><span class="n">arr</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;前缀和数组: </span><span class="si">{</span><span class="n">prefix_sum</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 查询区间 [1, 3] 的和 (索引1到3，即元素2, 3, 4)</span>
</span></span><span class="line"><span class="cl"><span class="n">result</span> <span class="o">=</span> <span class="n">range_sum</span><span class="p">(</span><span class="n">prefix_sum</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;区间 [1, 3] 的和: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>  <span class="c1"># 输出 9 (2 + 3 + 4)</span>
</span></span></code></pre></div><p><strong>算法解释</strong>：</p>
<ul>
<li><code>build_prefix_sum</code> 函数通过遍历输入数组并累加每个元素来构建前缀和数组</li>
<li>前缀和数组的第一个元素初始化为0，表示空区间的和</li>
<li><code>range_sum</code> 函数利用前缀和的性质：区间[start, end]的和 = prefix_sum[end+1] - prefix_sum[start]</li>
</ul>
<h3 id="2-累计出现次数前缀数组">2. 累计出现次数前缀数组</h3>
<p>用于快速查询某个特定值在指定区间内的出现次数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">build_prefix_count</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;构建目标值的前缀计数数组&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">prefix_count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># 初始化前缀计数数组</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">prefix_count</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prefix_count</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 如果是目标值，计数加1</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">prefix_count</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prefix_count</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># 否则，计数不变</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">prefix_count</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">count_range_occurrences</span><span class="p">(</span><span class="n">prefix_count</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;计算区间内目标值的出现次数&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">prefix_count</span><span class="p">[</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">prefix_count</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">target</span> <span class="o">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="n">prefix_count</span> <span class="o">=</span> <span class="n">build_prefix_count</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;原数组: </span><span class="si">{</span><span class="n">arr</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;目标值 </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2"> 的前缀计数数组: </span><span class="si">{</span><span class="n">prefix_count</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 查询区间 [1, 4] 中目标值的出现次数</span>
</span></span><span class="line"><span class="cl"><span class="n">result</span> <span class="o">=</span> <span class="n">count_range_occurrences</span><span class="p">(</span><span class="n">prefix_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;区间 [1, 4] 中值 </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2"> 的出现次数: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>  <span class="c1"># 输出 3</span>
</span></span></code></pre></div><p><strong>算法解释</strong>：</p>
<ul>
<li><code>build_prefix_count</code> 函数构建一个前缀计数数组，记录到当前位置为止目标值的累计出现次数</li>
<li>查询时同样使用差值的方法：区间内出现次数 = prefix_count[end+1] - prefix_count[start]</li>
</ul>
<h3 id="3-累积最大值前缀数组">3. 累积最大值前缀数组</h3>
<p>用于快速查询从数组开始到某个位置的最大值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">build_prefix_max</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;构建前缀最大值数组&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">prefix_max</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>  <span class="c1"># 初始化前缀最大值数组，第一个元素为数组的第一个元素</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
</span></span><span class="line"><span class="cl">        <span class="n">prefix_max</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">prefix_max</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">num</span><span class="p">))</span>  <span class="c1"># 记录到当前位置为止的最大值</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">prefix_max</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">prefix_max_query</span><span class="p">(</span><span class="n">prefix_max</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;查询从开始到指定位置的最大值&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">prefix_max</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">prefix_max</span> <span class="o">=</span> <span class="n">build_prefix_max</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;原数组: </span><span class="si">{</span><span class="n">arr</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;前缀最大值数组: </span><span class="si">{</span><span class="n">prefix_max</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 查询从开始到索引3的最大值</span>
</span></span><span class="line"><span class="cl"><span class="n">result</span> <span class="o">=</span> <span class="n">prefix_max_query</span><span class="p">(</span><span class="n">prefix_max</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;从开始到索引3的最大值: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>  <span class="c1"># 输出 5</span>
</span></span></code></pre></div><p><strong>算法解释</strong>：</p>
<ul>
<li><code>build_prefix_max</code> 函数构建一个前缀最大值数组，记录到每个位置为止的最大值</li>
<li>这种方法特别适用于需要频繁查询&quot;从开始到某个位置的最大值&quot;的场景</li>
</ul>
<h2 id="二维前缀和">二维前缀和</h2>
<p>对于二维数组，我们也可以构建二维前缀和来快速计算矩形区域的和。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">build_2d_prefix_sum</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;构建二维前缀和数组&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="ow">not</span> <span class="n">matrix</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="n">prefix_2d</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">cols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">rows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">prefix_2d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> 
</span></span><span class="line"><span class="cl">                              <span class="n">prefix_2d</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> 
</span></span><span class="line"><span class="cl">                              <span class="n">prefix_2d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> 
</span></span><span class="line"><span class="cl">                              <span class="n">prefix_2d</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">prefix_2d</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">range_sum_2d</span><span class="p">(</span><span class="n">prefix_2d</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;计算矩形区域的和&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">prefix_2d</span><span class="p">[</span><span class="n">x2</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">y2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> 
</span></span><span class="line"><span class="cl">            <span class="n">prefix_2d</span><span class="p">[</span><span class="n">x1</span><span class="p">][</span><span class="n">y2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> 
</span></span><span class="line"><span class="cl">            <span class="n">prefix_2d</span><span class="p">[</span><span class="n">x2</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">y1</span><span class="p">]</span> <span class="o">+</span> 
</span></span><span class="line"><span class="cl">            <span class="n">prefix_2d</span><span class="p">[</span><span class="n">x1</span><span class="p">][</span><span class="n">y1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="n">matrix</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">prefix_2d</span> <span class="o">=</span> <span class="n">build_2d_prefix_sum</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 查询矩形区域 (0,0) 到 (1,1) 的和</span>
</span></span><span class="line"><span class="cl"><span class="n">result</span> <span class="o">=</span> <span class="n">range_sum_2d</span><span class="p">(</span><span class="n">prefix_2d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;矩形区域 (0,0) 到 (1,1) 的和: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>  <span class="c1"># 输出 12 (1+2+4+5)</span>
</span></span></code></pre></div><h2 id="差分数组">差分数组</h2>
<p>差分数组是前缀和的逆运算，主要用于处理区间更新问题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">build_difference_array</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;构建差分数组&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">diff</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">        <span class="n">diff</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">diff</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">range_update</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">delta</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;区间更新：给[start, end]区间的所有元素加上delta&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">diff</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">diff</span><span class="p">[</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">delta</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">restore_from_difference</span><span class="p">(</span><span class="n">diff</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;从差分数组恢复原数组&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">diff</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 示例使用</span>
</span></span><span class="line"><span class="cl"><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">diff</span> <span class="o">=</span> <span class="n">build_difference_array</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;原数组: </span><span class="si">{</span><span class="n">arr</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;差分数组: </span><span class="si">{</span><span class="n">diff</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 给区间 [1, 3] 的所有元素加上 10</span>
</span></span><span class="line"><span class="cl"><span class="n">range_update</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">updated_arr</span> <span class="o">=</span> <span class="n">restore_from_difference</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;更新后的数组: </span><span class="si">{</span><span class="n">updated_arr</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>  <span class="c1"># 输出 [1, 12, 13, 14, 5]</span>
</span></span></code></pre></div><h2 id="实际应用场景">实际应用场景</h2>
<h3 id="1-区间查询问题">1. 区间查询问题</h3>
<ul>
<li>数组区间和查询</li>
<li>区间最值查询</li>
<li>区间元素计数</li>
</ul>
<h3 id="2-动态规划优化">2. 动态规划优化</h3>
<ul>
<li>利用前缀和优化状态转移</li>
<li>减少重复计算</li>
</ul>
<h3 id="3-字符串处理">3. 字符串处理</h3>
<ul>
<li>子串特征统计</li>
<li>模式匹配优化</li>
</ul>
<h3 id="4-图像处理">4. 图像处理</h3>
<ul>
<li>积分图像计算</li>
<li>快速区域特征提取</li>
</ul>
<h2 id="时间复杂度分析">时间复杂度分析</h2>
<table>
  <thead>
      <tr>
          <th>操作</th>
          <th>朴素方法</th>
          <th>前缀和方法</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>预处理</td>
          <td>O(1)</td>
          <td>O(n)</td>
      </tr>
      <tr>
          <td>单次查询</td>
          <td>O(n)</td>
          <td>O(1)</td>
      </tr>
      <tr>
          <td>m次查询</td>
          <td>O(m×n)</td>
          <td>O(n + m)</td>
      </tr>
  </tbody>
</table>
<p>当查询次数较多时，前缀和方法的优势非常明显。</p>
<h2 id="总结">总结</h2>
<p>前缀和算法是一种以空间换时间的经典算法技巧，通过预处理构建辅助数组，可以显著提高区间查询的效率。掌握前缀和及其变体对于解决各种算法问题都有重要意义。</p>
<p>关键要点：</p>
<ol>
<li><strong>预处理</strong>：构建前缀数组需要O(n)时间</li>
<li><strong>快速查询</strong>：单次查询只需O(1)时间</li>
<li><strong>灵活应用</strong>：可以扩展到二维、多维以及各种统计信息</li>
<li><strong>与差分结合</strong>：可以高效处理区间更新问题</li>
</ol>
<p>前缀和算法在竞赛编程、实际开发中都有广泛应用，是每个程序员都应该掌握的基础算法技巧。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
