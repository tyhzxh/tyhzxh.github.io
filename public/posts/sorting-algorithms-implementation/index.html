<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>经典排序算法实现与分析 | tyhzxh的个人博客</title>
<meta name="keywords" content="算法, 排序, 数据结构, C&#43;&#43;, 算法分析">
<meta name="description" content="详细介绍和实现经典排序算法，包括选择排序、插入排序、冒泡排序、快速排序、归并排序和堆排序，并提供性能测试代码">
<meta name="author" content="tyhzxh">
<link rel="canonical" href="https://tyhzxh.github.io/posts/sorting-algorithms-implementation/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8ee78296343cf29844826f6d943ca1b6638fc5059dcdf673ace996a7617f1b69.css" integrity="sha256-jueCljQ88phEgm9tlDyhtmOPxQWdzfZzrOmWp2F/G2k=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://tyhzxh.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://tyhzxh.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://tyhzxh.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://tyhzxh.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://tyhzxh.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://tyhzxh.github.io/posts/sorting-algorithms-implementation/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<style>
/* 归档页面摘要样式 */
.archive-summary {
  margin-bottom: 2rem;
  padding: 1rem;
  background: var(--theme);
  border-radius: 8px;
  border: 1px solid var(--border);
  text-align: center;
  color: var(--secondary);
  font-size: 0.9rem;
}

/* 分页导航样式 */
.pagination {
  display: flex !important;
  justify-content: center;
  align-items: center;
  gap: 1rem;
  margin: 3rem 0;
  padding: 2rem 0;
  border-top: 1px solid var(--border);
}

/* 覆盖主题默认样式 */
.pagination a.pagination-prev,
.pagination a.pagination-next {
  padding: 0.75rem 1.5rem !important;
  background: var(--entry) !important;
  border: 1px solid var(--border) !important;
  border-radius: 6px !important;
  text-decoration: none !important;
  color: var(--primary) !important;
  font-weight: 500 !important;
  transition: all 0.3s ease !important;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05) !important;
  font-size: 14px !important;
  line-height: normal !important;
}

.pagination a.pagination-prev:hover,
.pagination a.pagination-next:hover {
  background: var(--hljs-bg) !important;
  color: var(--primary) !important;
  transform: translateY(-2px) !important;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1) !important;
  border-color: var(--tertiary) !important;
}

.pagination-numbers {
  display: flex;
  gap: 0.5rem;
  align-items: center;
}

.pagination a.pagination-number,
.pagination-current {
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  width: 2.5rem !important;
  height: 2.5rem !important;
  border-radius: 50% !important;
  text-decoration: none !important;
  font-weight: 500 !important;
  transition: all 0.3s ease !important;
  font-size: 14px !important;
  line-height: normal !important;
  padding: 0 !important;
}

.pagination a.pagination-number {
  background: var(--entry) !important;
  border: 1px solid var(--border) !important;
  color: var(--primary) !important;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05) !important;
}

.pagination a.pagination-number:hover {
  background: var(--hljs-bg) !important;
  color: var(--primary) !important;
  transform: scale(1.1) !important;
  border-color: var(--tertiary) !important;
}

.pagination-current {
  background: var(--tertiary) !important;
  color: var(--primary) !important;
  border: 1px solid var(--tertiary) !important;
  font-weight: 600 !important;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
}

/* 响应式设计 */
@media (max-width: 768px) {
  .pagination {
    flex-direction: column;
    gap: 1rem;
  }
  
  .pagination-prev,
  .pagination-next {
    width: 100%;
    text-align: center;
  }
  
  .pagination-numbers {
    order: -1;
  }
  
  .archive-summary {
    font-size: 0.8rem;
    padding: 0.75rem;
  }
}

/* 暗色主题适配 */
[data-theme="dark"] .archive-summary {
  background: var(--entry);
}

[data-theme="dark"] .pagination-prev,
[data-theme="dark"] .pagination-next,
[data-theme="dark"] .pagination-number {
  background: var(--entry);
  border-color: var(--border);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

[data-theme="dark"] .pagination-prev:hover,
[data-theme="dark"] .pagination-next:hover,
[data-theme="dark"] .pagination-number:hover {
  background: var(--hljs-bg);
  border-color: var(--tertiary);
}

[data-theme="dark"] .pagination-current {
  background: var(--tertiary);
  border-color: var(--tertiary);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}
</style><meta property="og:url" content="https://tyhzxh.github.io/posts/sorting-algorithms-implementation/">
  <meta property="og:site_name" content="tyhzxh的个人博客">
  <meta property="og:title" content="经典排序算法实现与分析">
  <meta property="og:description" content="详细介绍和实现经典排序算法，包括选择排序、插入排序、冒泡排序、快速排序、归并排序和堆排序，并提供性能测试代码">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-27T22:11:13+08:00">
    <meta property="article:modified_time" content="2025-08-06T08:51:21+08:00">
    <meta property="article:tag" content="算法">
    <meta property="article:tag" content="排序">
    <meta property="article:tag" content="数据结构">
    <meta property="article:tag" content="C&#43;&#43;">
    <meta property="article:tag" content="算法分析">
    <meta property="og:image" content="https://images.unsplash.com/photo-1518186285589-2f7649de83e0?w=800&amp;h=400&amp;fit=crop">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://images.unsplash.com/photo-1518186285589-2f7649de83e0?w=800&amp;h=400&amp;fit=crop">
<meta name="twitter:title" content="经典排序算法实现与分析">
<meta name="twitter:description" content="详细介绍和实现经典排序算法，包括选择排序、插入排序、冒泡排序、快速排序、归并排序和堆排序，并提供性能测试代码">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://tyhzxh.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "经典排序算法实现与分析",
      "item": "https://tyhzxh.github.io/posts/sorting-algorithms-implementation/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "经典排序算法实现与分析",
  "name": "经典排序算法实现与分析",
  "description": "详细介绍和实现经典排序算法，包括选择排序、插入排序、冒泡排序、快速排序、归并排序和堆排序，并提供性能测试代码",
  "keywords": [
    "算法", "排序", "数据结构", "C++", "算法分析"
  ],
  "articleBody": "前言 这是某次学校数据结构实验中实现的基本排序算法。数据结构这门课的难点在于实现的复杂性，每次实验都需要封装数据结构，编写测试程序，对于初学者来说确实是一个挑战。\n通过这次实验，我深刻体会到了代码质量的重要性。虽然当时的代码可能不够优雅，但这正是学习过程中的宝贵经历。\n基本数据结构封装 首先定义基本的数据结构和工具函数：\n#include \"stdio.h\" #include #include #include #define ERROR 0 #define OK 1 #define Overflow 2 #define Underflow 3 #define NotPresent 4 // 元素不存在 #define Duplicate 5 // 元素重复存在 #define MaxSize 100001 typedef int KeyType; typedef int Status; typedef int DataType; typedef struct Entry { KeyType key; DataType data; } entry; typedef struct list { int n; Entry D[MaxSize]; } List; // 输出函数 Status printlist(list* l) { for(int i = 0; i \u003c l-\u003en; i++) { printf(\"%d \", l-\u003eD[i].key); } return OK; } // 交换函数 void swap(Entry* a, Entry* b) { Entry temp = *a; *a = *b; *b = temp; } 排序算法实现 1. 简单选择排序 选择排序的基本思想是每次从未排序的元素中选择最小的元素，放到已排序序列的末尾。\nStatus choosesort(list* l) { for(int i = 0; i \u003c l-\u003en - 1; i++) { int min = i; for(int j = i + 1; j \u003c l-\u003en; j++) { if(l-\u003eD[min].key \u003e l-\u003eD[j].key) min = j; } swap(\u0026l-\u003eD[i], \u0026l-\u003eD[min]); } return OK; } 时间复杂度：O(n²)\n空间复杂度：O(1)\n稳定性：不稳定\n2. 直接插入排序 插入排序的基本思想是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。\nStatus insertsort(list* l) { int i, j; for(i = 1; i \u003c l-\u003en; i++) { Entry temp = l-\u003eD[i]; j = i - 1; while(j \u003e= 0) { if(l-\u003eD[j].key \u003e temp.key) { l-\u003eD[j + 1] = l-\u003eD[j]; l-\u003eD[j] = temp; } j--; } } return OK; } 时间复杂度：O(n²)\n空间复杂度：O(1)\n稳定性：稳定\n3. 冒泡排序 冒泡排序是一种简单的排序算法，它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。\nvoid Bubblesort(list* l) { for(int i = 0; i \u003c l-\u003en - 1; i++) { int start = 0, end = 1; while (end \u003c l-\u003en) { if (l-\u003eD[start].key \u003e l-\u003eD[end].key) { Entry temp = l-\u003eD[start]; l-\u003eD[start] = l-\u003eD[end]; l-\u003eD[end] = temp; } ++start; ++end; } } } 时间复杂度：O(n²)\n空间复杂度：O(1)\n稳定性：稳定\n4. 快速排序 快速排序使用分治法策略来把一个序列分为较小和较大的2个子序列，然后递归地排序两个子序列。\nvoid QuickSort(List* l, int low, int high) { if (low \u003c high) { int i = low; int j = high; Entry pivot = l-\u003eD[low]; // 选择第一个元素作为基准 while (i \u003c j) { // 从右向左找小于基准的元素 while (i \u003c j \u0026\u0026 l-\u003eD[j].key \u003e pivot.key) { j--; } if(i \u003c j) l-\u003eD[i++] = l-\u003eD[j]; // 从左向右找大于基准的元素 while(i \u003c j \u0026\u0026 l-\u003eD[i].key \u003c pivot.key) { i++; } if(i \u003c j) l-\u003eD[j--] = l-\u003eD[i]; } l-\u003eD[i] = pivot; QuickSort(l, low, i - 1); // 递归排序左半部分 QuickSort(l, i + 1, high); // 递归排序右半部分 } } 时间复杂度：平均O(n log n)，最坏O(n²)\n空间复杂度：O(log n)\n稳定性：不稳定\n快速排序确实很精妙，理解和记忆都需要时间。它的核心思想是分治法，通过选择一个基准元素，将数组分为两部分，然后递归地对两部分进行排序。\n5. 归并排序 归并排序采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列。\nvoid merge(list* l, int left, int lmid, int rmid, int right) { int i = left, j = rmid; // i,j指向left和right list temp; int index = 0; // 合并两个有序序列 while(i \u003c= lmid \u0026\u0026 j \u003c= right) { if(l-\u003eD[i].key \u003c= l-\u003eD[j].key) { temp.D[index++] = l-\u003eD[i++]; } else { temp.D[index++] = l-\u003eD[j++]; } } // 复制剩余元素 while(i \u003c= lmid) { temp.D[index++] = l-\u003eD[i++]; } while (j \u003c= right) { temp.D[index++] = l-\u003eD[j++]; } // 将临时数组的内容复制回原数组 int n = 0; for(int k = left; k \u003c= right; k++) { l-\u003eD[k] = temp.D[n++]; } } Status mergesort(list* l, int left, int right) { if(left \u003c right) { int mid = left + (right - left) / 2; mergesort(l, left, mid); mergesort(l, mid + 1, right); merge(l, left, mid, mid + 1, right); } return OK; } 时间复杂度：O(n log n)\n空间复杂度：O(n)\n稳定性：稳定\n6. 堆排序 堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质。\nvoid downadjust(list* l, int start, int end) { Entry temp = l-\u003eD[start]; for(int i = 2 * start + 1; i \u003c= end; i *= 2) { // 如果左子结点小于右子结点 if(i \u003c end \u0026\u0026 l-\u003eD[i].key \u003e l-\u003eD[i + 1].key) i++; // i指向右子结点 // 如果父结点大于子结点 if(temp.key \u003e= l-\u003eD[i].key) break; // 调整结束 l-\u003eD[start] = l-\u003eD[i]; // 否则将子结点值赋给父结点 start = i; // 重新赋值开始指针 } l-\u003eD[start] = temp; // 调整结束后，将temp值放在最终位置 } Status heapsort(list* l) { // 建堆 for(int i = l-\u003en / 2; i \u003e= 0; i--) { downadjust(l, i, l-\u003en); } return OK; } 时间复杂度：O(n log n)\n空间复杂度：O(1)\n稳定性：不稳定\n测试框架 数据初始化 list* initlist(int n) { list* l; l = (list*)malloc(sizeof(list)); l-\u003en = n; if(n \u003e MaxSize) return nullptr; srand(time(0)); // 生成随机种子 for(int i = 0; i \u003c n; i++) { l-\u003eD[i].key = (rand() % 1000) + 1; // 随机数赋值 l-\u003eD[i].data = (rand() % 50) + 1; } return l; } void deletelist(list* l) { if(!l) return; free(l); } 性能测试函数 Status testchoosesort(int n) { list* l0 = initlist(n); printf(\"\\n\\nmake a new list!\\n\"); printlist(l0); clock_t start, finish; start = clock(); choosesort(l0); finish = clock(); printf(\"\\nafter choosesort\\n\"); printlist(l0); double TheTimes = (double)(finish - start) / CLOCKS_PER_SEC; printf(\"消耗%f秒。\\n\", TheTimes); deletelist(l0); return OK; } Status testquicksort(int n) { list* l0 = initlist(n); printf(\"\\n\\nmake a new list!\\n\"); printlist(l0); clock_t start, finish; start = clock(); QuickSort(l0, 0, l0-\u003en - 1); finish = clock(); printf(\"\\nafter quicksort\\n\"); printlist(l0); double TheTimes = (double)(finish - start) / CLOCKS_PER_SEC; printf(\"消耗%f秒。\\n\", TheTimes); deletelist(l0); return OK; } // 主测试函数 int main() { printf(\"测试不同规模数据的排序性能：\\n\"); testinsertsort(500); testchoosesort(500); testBubblesort(500); testquicksort(500); testmergesort(500); return 0; } 算法性能比较 排序算法 平均时间复杂度 最坏时间复杂度 最好时间复杂度 空间复杂度 稳定性 选择排序 O(n²) O(n²) O(n²) O(1) 不稳定 插入排序 O(n²) O(n²) O(n) O(1) 稳定 冒泡排序 O(n²) O(n²) O(n) O(1) 稳定 快速排序 O(n log n) O(n²) O(n log n) O(log n) 不稳定 归并排序 O(n log n) O(n log n) O(n log n) O(n) 稳定 堆排序 O(n log n) O(n log n) O(n log n) O(1) 不稳定 总结 通过这次排序算法的实现和测试，我们可以得出以下结论：\n简单排序算法（选择、插入、冒泡）实现简单，但时间复杂度较高，适合小规模数据。\n高效排序算法（快速、归并、堆）时间复杂度较低，适合大规模数据处理。\n稳定性在某些应用场景中很重要，需要根据具体需求选择合适的算法。\n空间复杂度也是选择算法时需要考虑的重要因素。\n学习排序算法不仅仅是为了应付考试，更重要的是理解算法设计的思想和优化策略。每种算法都有其适用的场景，在实际开发中需要根据具体情况选择最合适的算法。\n代码质量的提升确实需要大量的练习和思考。虽然当时的代码可能不够完美，但这正是成长过程中的重要一步。\n",
  "wordCount" : "828",
  "inLanguage": "en",
  "image":"https://images.unsplash.com/photo-1518186285589-2f7649de83e0?w=800\u0026h=400\u0026fit=crop","datePublished": "2024-02-27T22:11:13+08:00",
  "dateModified": "2025-08-06T08:51:21+08:00",
  "author":{
    "@type": "Person",
    "name": "tyhzxh"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://tyhzxh.github.io/posts/sorting-algorithms-implementation/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "tyhzxh的个人博客",
    "logo": {
      "@type": "ImageObject",
      "url": "https://tyhzxh.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://tyhzxh.github.io/" accesskey="h" title="tyhzxh的个人博客 (Alt + H)">tyhzxh的个人博客</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://tyhzxh.github.io/" title="首页">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="https://tyhzxh.github.io/posts/" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="https://tyhzxh.github.io/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://tyhzxh.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://tyhzxh.github.io/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://tyhzxh.github.io/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://tyhzxh.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://tyhzxh.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      经典排序算法实现与分析
    </h1>
    <div class="post-description">
      详细介绍和实现经典排序算法，包括选择排序、插入排序、冒泡排序、快速排序、归并排序和堆排序，并提供性能测试代码
    </div>
    <div class="post-meta"><span title='2024-02-27 22:11:13 +0800 CST'>February 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;tyhzxh

</div>
  </header> 
<figure class="entry-cover">
        <img loading="eager" src="https://images.unsplash.com/photo-1518186285589-2f7649de83e0?w=800&amp;h=400&amp;fit=crop" alt="排序算法可视化">
        
</figure><div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%89%8d%e8%a8%80" aria-label="前言">前言</a></li>
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%b0%81%e8%a3%85" aria-label="基本数据结构封装">基本数据结构封装</a></li>
                <li>
                    <a href="#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0" aria-label="排序算法实现">排序算法实现</a><ul>
                        
                <li>
                    <a href="#1-%e7%ae%80%e5%8d%95%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f" aria-label="1. 简单选择排序">1. 简单选择排序</a></li>
                <li>
                    <a href="#2-%e7%9b%b4%e6%8e%a5%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f" aria-label="2. 直接插入排序">2. 直接插入排序</a></li>
                <li>
                    <a href="#3-%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f" aria-label="3. 冒泡排序">3. 冒泡排序</a></li>
                <li>
                    <a href="#4-%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f" aria-label="4. 快速排序">4. 快速排序</a></li>
                <li>
                    <a href="#5-%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f" aria-label="5. 归并排序">5. 归并排序</a></li>
                <li>
                    <a href="#6-%e5%a0%86%e6%8e%92%e5%ba%8f" aria-label="6. 堆排序">6. 堆排序</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%b5%8b%e8%af%95%e6%a1%86%e6%9e%b6" aria-label="测试框架">测试框架</a><ul>
                        
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="数据初始化">数据初始化</a></li>
                <li>
                    <a href="#%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95%e5%87%bd%e6%95%b0" aria-label="性能测试函数">性能测试函数</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e6%80%a7%e8%83%bd%e6%af%94%e8%be%83" aria-label="算法性能比较">算法性能比较</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h2>
<p>这是某次学校数据结构实验中实现的基本排序算法。数据结构这门课的难点在于实现的复杂性，每次实验都需要封装数据结构，编写测试程序，对于初学者来说确实是一个挑战。</p>
<p>通过这次实验，我深刻体会到了代码质量的重要性。虽然当时的代码可能不够优雅，但这正是学习过程中的宝贵经历。</p>
<h2 id="基本数据结构封装">基本数据结构封装<a hidden class="anchor" aria-hidden="true" href="#基本数据结构封装">#</a></h2>
<p>首先定义基本的数据结构和工具函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;stdio.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define ERROR 0
</span></span></span><span class="line"><span class="cl"><span class="cp">#define OK 1
</span></span></span><span class="line"><span class="cl"><span class="cp">#define Overflow 2
</span></span></span><span class="line"><span class="cl"><span class="cp">#define Underflow 3
</span></span></span><span class="line"><span class="cl"><span class="cp">#define NotPresent 4    </span><span class="c1">// 元素不存在
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define Duplicate 5     </span><span class="c1">// 元素重复存在
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define MaxSize 100001
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">int</span> <span class="n">KeyType</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">int</span> <span class="n">Status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">int</span> <span class="n">DataType</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">Entry</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">KeyType</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">DataType</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">entry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">list</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Entry</span> <span class="n">D</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">List</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 输出函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Status</span> <span class="nf">printlist</span><span class="p">(</span><span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 交换函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">Entry</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">Entry</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Entry</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="排序算法实现">排序算法实现<a hidden class="anchor" aria-hidden="true" href="#排序算法实现">#</a></h2>
<h3 id="1-简单选择排序">1. 简单选择排序<a hidden class="anchor" aria-hidden="true" href="#1-简单选择排序">#</a></h3>
<p>选择排序的基本思想是每次从未排序的元素中选择最小的元素，放到已排序序列的末尾。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Status</span> <span class="nf">choosesort</span><span class="p">(</span><span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">min</span><span class="p">].</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">min</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">min</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>时间复杂度</strong>：O(n²)<br>
<strong>空间复杂度</strong>：O(1)<br>
<strong>稳定性</strong>：不稳定</p>
<h3 id="2-直接插入排序">2. 直接插入排序<a hidden class="anchor" aria-hidden="true" href="#2-直接插入排序">#</a></h3>
<p>插入排序的基本思想是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Status</span> <span class="nf">insertsort</span><span class="p">(</span><span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Entry</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">temp</span><span class="p">.</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">j</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>时间复杂度</strong>：O(n²)<br>
<strong>空间复杂度</strong>：O(1)<br>
<strong>稳定性</strong>：稳定</p>
<h3 id="3-冒泡排序">3. 冒泡排序<a hidden class="anchor" aria-hidden="true" href="#3-冒泡排序">#</a></h3>
<p>冒泡排序是一种简单的排序算法，它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">Bubblesort</span><span class="p">(</span><span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">start</span><span class="p">].</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">end</span><span class="p">].</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">Entry</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">end</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>时间复杂度</strong>：O(n²)<br>
<strong>空间复杂度</strong>：O(1)<br>
<strong>稳定性</strong>：稳定</p>
<h3 id="4-快速排序">4. 快速排序<a hidden class="anchor" aria-hidden="true" href="#4-快速排序">#</a></h3>
<p>快速排序使用分治法策略来把一个序列分为较小和较大的2个子序列，然后递归地排序两个子序列。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="n">List</span><span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">high</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Entry</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">low</span><span class="p">];</span> <span class="c1">// 选择第一个元素作为基准
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 从右向左找小于基准的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">.</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">j</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                
</span></span><span class="line"><span class="cl">            <span class="c1">// 从左向右找大于基准的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">.</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pivot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">QuickSort</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>   <span class="c1">// 递归排序左半部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">QuickSort</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span> <span class="c1">// 递归排序右半部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>时间复杂度</strong>：平均O(n log n)，最坏O(n²)<br>
<strong>空间复杂度</strong>：O(log n)<br>
<strong>稳定性</strong>：不稳定</p>
<blockquote>
<p>快速排序确实很精妙，理解和记忆都需要时间。它的核心思想是分治法，通过选择一个基准元素，将数组分为两部分，然后递归地对两部分进行排序。</p></blockquote>
<h3 id="5-归并排序">5. 归并排序<a hidden class="anchor" aria-hidden="true" href="#5-归并排序">#</a></h3>
<p>归并排序采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lmid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rmid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">rmid</span><span class="p">;</span> <span class="c1">// i,j指向left和right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">list</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 合并两个有序序列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">lmid</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">temp</span><span class="p">.</span><span class="n">D</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">temp</span><span class="p">.</span><span class="n">D</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 复制剩余元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">lmid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">temp</span><span class="p">.</span><span class="n">D</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">temp</span><span class="p">.</span><span class="n">D</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 将临时数组的内容复制回原数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Status</span> <span class="nf">mergesort</span><span class="p">(</span><span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">mergesort</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">mergesort</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">merge</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>时间复杂度</strong>：O(n log n)<br>
<strong>空间复杂度</strong>：O(n)<br>
<strong>稳定性</strong>：稳定</p>
<h3 id="6-堆排序">6. 堆排序<a hidden class="anchor" aria-hidden="true" href="#6-堆排序">#</a></h3>
<p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">downadjust</span><span class="p">(</span><span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Entry</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果左子结点小于右子结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span><span class="o">++</span><span class="p">;</span> <span class="c1">// i指向右子结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果父结点大于子结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">key</span> <span class="o">&gt;=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span> <span class="c1">// 调整结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            
</span></span><span class="line"><span class="cl">        <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// 否则将子结点值赋给父结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// 重新赋值开始指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span> <span class="c1">// 调整结束后，将temp值放在最终位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Status</span> <span class="nf">heapsort</span><span class="p">(</span><span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 建堆
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">downadjust</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>时间复杂度</strong>：O(n log n)<br>
<strong>空间复杂度</strong>：O(1)<br>
<strong>稳定性</strong>：不稳定</p>
<h2 id="测试框架">测试框架<a hidden class="anchor" aria-hidden="true" href="#测试框架">#</a></h2>
<h3 id="数据初始化">数据初始化<a hidden class="anchor" aria-hidden="true" href="#数据初始化">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">list</span><span class="o">*</span> <span class="nf">initlist</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">list</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">list</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">MaxSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span> <span class="c1">// 生成随机种子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 随机数赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">l</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">50</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">deletelist</span><span class="p">(</span><span class="n">list</span><span class="o">*</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">l</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">free</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="性能测试函数">性能测试函数<a hidden class="anchor" aria-hidden="true" href="#性能测试函数">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Status</span> <span class="nf">testchoosesort</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">list</span><span class="o">*</span> <span class="n">l0</span> <span class="o">=</span> <span class="n">initlist</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n\n</span><span class="s">make a new list!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printlist</span><span class="p">(</span><span class="n">l0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">clock_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">finish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">start</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">choosesort</span><span class="p">(</span><span class="n">l0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">finish</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">after choosesort</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printlist</span><span class="p">(</span><span class="n">l0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">TheTimes</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">finish</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;消耗%f秒。</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">TheTimes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">deletelist</span><span class="p">(</span><span class="n">l0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Status</span> <span class="nf">testquicksort</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">list</span><span class="o">*</span> <span class="n">l0</span> <span class="o">=</span> <span class="n">initlist</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n\n</span><span class="s">make a new list!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printlist</span><span class="p">(</span><span class="n">l0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">clock_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">finish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">start</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">QuickSort</span><span class="p">(</span><span class="n">l0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l0</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">finish</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">after quicksort</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printlist</span><span class="p">(</span><span class="n">l0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">TheTimes</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">finish</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;消耗%f秒。</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">TheTimes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">deletelist</span><span class="p">(</span><span class="n">l0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 主测试函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;测试不同规模数据的排序性能：</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">testinsertsort</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">testchoosesort</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">testBubblesort</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">testquicksort</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">testmergesort</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="算法性能比较">算法性能比较<a hidden class="anchor" aria-hidden="true" href="#算法性能比较">#</a></h2>
<table>
  <thead>
      <tr>
          <th>排序算法</th>
          <th>平均时间复杂度</th>
          <th>最坏时间复杂度</th>
          <th>最好时间复杂度</th>
          <th>空间复杂度</th>
          <th>稳定性</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>选择排序</td>
          <td>O(n²)</td>
          <td>O(n²)</td>
          <td>O(n²)</td>
          <td>O(1)</td>
          <td>不稳定</td>
      </tr>
      <tr>
          <td>插入排序</td>
          <td>O(n²)</td>
          <td>O(n²)</td>
          <td>O(n)</td>
          <td>O(1)</td>
          <td>稳定</td>
      </tr>
      <tr>
          <td>冒泡排序</td>
          <td>O(n²)</td>
          <td>O(n²)</td>
          <td>O(n)</td>
          <td>O(1)</td>
          <td>稳定</td>
      </tr>
      <tr>
          <td>快速排序</td>
          <td>O(n log n)</td>
          <td>O(n²)</td>
          <td>O(n log n)</td>
          <td>O(log n)</td>
          <td>不稳定</td>
      </tr>
      <tr>
          <td>归并排序</td>
          <td>O(n log n)</td>
          <td>O(n log n)</td>
          <td>O(n log n)</td>
          <td>O(n)</td>
          <td>稳定</td>
      </tr>
      <tr>
          <td>堆排序</td>
          <td>O(n log n)</td>
          <td>O(n log n)</td>
          <td>O(n log n)</td>
          <td>O(1)</td>
          <td>不稳定</td>
      </tr>
  </tbody>
</table>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<p>通过这次排序算法的实现和测试，我们可以得出以下结论：</p>
<ol>
<li>
<p><strong>简单排序算法</strong>（选择、插入、冒泡）实现简单，但时间复杂度较高，适合小规模数据。</p>
</li>
<li>
<p><strong>高效排序算法</strong>（快速、归并、堆）时间复杂度较低，适合大规模数据处理。</p>
</li>
<li>
<p><strong>稳定性</strong>在某些应用场景中很重要，需要根据具体需求选择合适的算法。</p>
</li>
<li>
<p><strong>空间复杂度</strong>也是选择算法时需要考虑的重要因素。</p>
</li>
</ol>
<p>学习排序算法不仅仅是为了应付考试，更重要的是理解算法设计的思想和优化策略。每种算法都有其适用的场景，在实际开发中需要根据具体情况选择最合适的算法。</p>
<blockquote>
<p>代码质量的提升确实需要大量的练习和思考。虽然当时的代码可能不够完美，但这正是成长过程中的重要一步。</p></blockquote>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://tyhzxh.github.io/tags/%E7%AE%97%E6%B3%95/">算法</a></li>
      <li><a href="https://tyhzxh.github.io/tags/%E6%8E%92%E5%BA%8F/">排序</a></li>
      <li><a href="https://tyhzxh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li>
      <li><a href="https://tyhzxh.github.io/tags/c&#43;&#43;/">C&#43;&#43;</a></li>
      <li><a href="https://tyhzxh.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/">算法分析</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://tyhzxh.github.io/posts/http-protocol-guide/">
    <span class="title">« Prev</span>
    <br>
    <span>HTTP协议详解：从基础到高级应用</span>
  </a>
  <a class="next" href="https://tyhzxh.github.io/posts/dynamic-programming-guide/">
    <span class="title">Next »</span>
    <br>
    <span>动态规划完全攻略：从入门到精通</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://tyhzxh.github.io/">tyhzxh的个人博客</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
