<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>经典排序算法实现与分析 | tyhzxh的个人博客</title><meta name=keywords content="算法,排序,数据结构,C++,算法分析"><meta name=description content="详细介绍和实现经典排序算法，包括选择排序、插入排序、冒泡排序、快速排序、归并排序和堆排序，并提供性能测试代码"><meta name=author content="tyhzxh"><link rel=canonical href=https://tyhzxh.github.io/posts/sorting-algorithms-implementation/><link crossorigin=anonymous href=/assets/css/stylesheet.8ee78296343cf29844826f6d943ca1b6638fc5059dcdf673ace996a7617f1b69.css integrity="sha256-jueCljQ88phEgm9tlDyhtmOPxQWdzfZzrOmWp2F/G2k=" rel="preload stylesheet" as=style><link rel=icon href=https://tyhzxh.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tyhzxh.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tyhzxh.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tyhzxh.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tyhzxh.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tyhzxh.github.io/posts/sorting-algorithms-implementation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://tyhzxh.github.io/posts/sorting-algorithms-implementation/"><meta property="og:site_name" content="tyhzxh的个人博客"><meta property="og:title" content="经典排序算法实现与分析"><meta property="og:description" content="详细介绍和实现经典排序算法，包括选择排序、插入排序、冒泡排序、快速排序、归并排序和堆排序，并提供性能测试代码"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-27T22:11:13+08:00"><meta property="article:modified_time" content="2025-08-06T08:51:21+08:00"><meta property="article:tag" content="算法"><meta property="article:tag" content="排序"><meta property="article:tag" content="数据结构"><meta property="article:tag" content="C++"><meta property="article:tag" content="算法分析"><meta property="og:image" content="https://images.unsplash.com/photo-1518186285589-2f7649de83e0?w=800&amp;h=400&amp;fit=crop"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1518186285589-2f7649de83e0?w=800&amp;h=400&amp;fit=crop"><meta name=twitter:title content="经典排序算法实现与分析"><meta name=twitter:description content="详细介绍和实现经典排序算法，包括选择排序、插入排序、冒泡排序、快速排序、归并排序和堆排序，并提供性能测试代码"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tyhzxh.github.io/posts/"},{"@type":"ListItem","position":2,"name":"经典排序算法实现与分析","item":"https://tyhzxh.github.io/posts/sorting-algorithms-implementation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"经典排序算法实现与分析","name":"经典排序算法实现与分析","description":"详细介绍和实现经典排序算法，包括选择排序、插入排序、冒泡排序、快速排序、归并排序和堆排序，并提供性能测试代码","keywords":["算法","排序","数据结构","C++","算法分析"],"articleBody":"前言 这是某次学校数据结构实验中实现的基本排序算法。数据结构这门课的难点在于实现的复杂性，每次实验都需要封装数据结构，编写测试程序，对于初学者来说确实是一个挑战。\n通过这次实验，我深刻体会到了代码质量的重要性。虽然当时的代码可能不够优雅，但这正是学习过程中的宝贵经历。\n基本数据结构封装 首先定义基本的数据结构和工具函数：\n#include \"stdio.h\" #include #include #include #define ERROR 0 #define OK 1 #define Overflow 2 #define Underflow 3 #define NotPresent 4 // 元素不存在 #define Duplicate 5 // 元素重复存在 #define MaxSize 100001 typedef int KeyType; typedef int Status; typedef int DataType; typedef struct Entry { KeyType key; DataType data; } entry; typedef struct list { int n; Entry D[MaxSize]; } List; // 输出函数 Status printlist(list* l) { for(int i = 0; i \u003c l-\u003en; i++) { printf(\"%d \", l-\u003eD[i].key); } return OK; } // 交换函数 void swap(Entry* a, Entry* b) { Entry temp = *a; *a = *b; *b = temp; } 排序算法实现 1. 简单选择排序 选择排序的基本思想是每次从未排序的元素中选择最小的元素，放到已排序序列的末尾。\nStatus choosesort(list* l) { for(int i = 0; i \u003c l-\u003en - 1; i++) { int min = i; for(int j = i + 1; j \u003c l-\u003en; j++) { if(l-\u003eD[min].key \u003e l-\u003eD[j].key) min = j; } swap(\u0026l-\u003eD[i], \u0026l-\u003eD[min]); } return OK; } 时间复杂度：O(n²)\n空间复杂度：O(1)\n稳定性：不稳定\n2. 直接插入排序 插入排序的基本思想是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。\nStatus insertsort(list* l) { int i, j; for(i = 1; i \u003c l-\u003en; i++) { Entry temp = l-\u003eD[i]; j = i - 1; while(j \u003e= 0) { if(l-\u003eD[j].key \u003e temp.key) { l-\u003eD[j + 1] = l-\u003eD[j]; l-\u003eD[j] = temp; } j--; } } return OK; } 时间复杂度：O(n²)\n空间复杂度：O(1)\n稳定性：稳定\n3. 冒泡排序 冒泡排序是一种简单的排序算法，它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。\nvoid Bubblesort(list* l) { for(int i = 0; i \u003c l-\u003en - 1; i++) { int start = 0, end = 1; while (end \u003c l-\u003en) { if (l-\u003eD[start].key \u003e l-\u003eD[end].key) { Entry temp = l-\u003eD[start]; l-\u003eD[start] = l-\u003eD[end]; l-\u003eD[end] = temp; } ++start; ++end; } } } 时间复杂度：O(n²)\n空间复杂度：O(1)\n稳定性：稳定\n4. 快速排序 快速排序使用分治法策略来把一个序列分为较小和较大的2个子序列，然后递归地排序两个子序列。\nvoid QuickSort(List* l, int low, int high) { if (low \u003c high) { int i = low; int j = high; Entry pivot = l-\u003eD[low]; // 选择第一个元素作为基准 while (i \u003c j) { // 从右向左找小于基准的元素 while (i \u003c j \u0026\u0026 l-\u003eD[j].key \u003e pivot.key) { j--; } if(i \u003c j) l-\u003eD[i++] = l-\u003eD[j]; // 从左向右找大于基准的元素 while(i \u003c j \u0026\u0026 l-\u003eD[i].key \u003c pivot.key) { i++; } if(i \u003c j) l-\u003eD[j--] = l-\u003eD[i]; } l-\u003eD[i] = pivot; QuickSort(l, low, i - 1); // 递归排序左半部分 QuickSort(l, i + 1, high); // 递归排序右半部分 } } 时间复杂度：平均O(n log n)，最坏O(n²)\n空间复杂度：O(log n)\n稳定性：不稳定\n快速排序确实很精妙，理解和记忆都需要时间。它的核心思想是分治法，通过选择一个基准元素，将数组分为两部分，然后递归地对两部分进行排序。\n5. 归并排序 归并排序采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列。\nvoid merge(list* l, int left, int lmid, int rmid, int right) { int i = left, j = rmid; // i,j指向left和right list temp; int index = 0; // 合并两个有序序列 while(i \u003c= lmid \u0026\u0026 j \u003c= right) { if(l-\u003eD[i].key \u003c= l-\u003eD[j].key) { temp.D[index++] = l-\u003eD[i++]; } else { temp.D[index++] = l-\u003eD[j++]; } } // 复制剩余元素 while(i \u003c= lmid) { temp.D[index++] = l-\u003eD[i++]; } while (j \u003c= right) { temp.D[index++] = l-\u003eD[j++]; } // 将临时数组的内容复制回原数组 int n = 0; for(int k = left; k \u003c= right; k++) { l-\u003eD[k] = temp.D[n++]; } } Status mergesort(list* l, int left, int right) { if(left \u003c right) { int mid = left + (right - left) / 2; mergesort(l, left, mid); mergesort(l, mid + 1, right); merge(l, left, mid, mid + 1, right); } return OK; } 时间复杂度：O(n log n)\n空间复杂度：O(n)\n稳定性：稳定\n6. 堆排序 堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质。\nvoid downadjust(list* l, int start, int end) { Entry temp = l-\u003eD[start]; for(int i = 2 * start + 1; i \u003c= end; i *= 2) { // 如果左子结点小于右子结点 if(i \u003c end \u0026\u0026 l-\u003eD[i].key \u003e l-\u003eD[i + 1].key) i++; // i指向右子结点 // 如果父结点大于子结点 if(temp.key \u003e= l-\u003eD[i].key) break; // 调整结束 l-\u003eD[start] = l-\u003eD[i]; // 否则将子结点值赋给父结点 start = i; // 重新赋值开始指针 } l-\u003eD[start] = temp; // 调整结束后，将temp值放在最终位置 } Status heapsort(list* l) { // 建堆 for(int i = l-\u003en / 2; i \u003e= 0; i--) { downadjust(l, i, l-\u003en); } return OK; } 时间复杂度：O(n log n)\n空间复杂度：O(1)\n稳定性：不稳定\n测试框架 数据初始化 list* initlist(int n) { list* l; l = (list*)malloc(sizeof(list)); l-\u003en = n; if(n \u003e MaxSize) return nullptr; srand(time(0)); // 生成随机种子 for(int i = 0; i \u003c n; i++) { l-\u003eD[i].key = (rand() % 1000) + 1; // 随机数赋值 l-\u003eD[i].data = (rand() % 50) + 1; } return l; } void deletelist(list* l) { if(!l) return; free(l); } 性能测试函数 Status testchoosesort(int n) { list* l0 = initlist(n); printf(\"\\n\\nmake a new list!\\n\"); printlist(l0); clock_t start, finish; start = clock(); choosesort(l0); finish = clock(); printf(\"\\nafter choosesort\\n\"); printlist(l0); double TheTimes = (double)(finish - start) / CLOCKS_PER_SEC; printf(\"消耗%f秒。\\n\", TheTimes); deletelist(l0); return OK; } Status testquicksort(int n) { list* l0 = initlist(n); printf(\"\\n\\nmake a new list!\\n\"); printlist(l0); clock_t start, finish; start = clock(); QuickSort(l0, 0, l0-\u003en - 1); finish = clock(); printf(\"\\nafter quicksort\\n\"); printlist(l0); double TheTimes = (double)(finish - start) / CLOCKS_PER_SEC; printf(\"消耗%f秒。\\n\", TheTimes); deletelist(l0); return OK; } // 主测试函数 int main() { printf(\"测试不同规模数据的排序性能：\\n\"); testinsertsort(500); testchoosesort(500); testBubblesort(500); testquicksort(500); testmergesort(500); return 0; } 算法性能比较 排序算法 平均时间复杂度 最坏时间复杂度 最好时间复杂度 空间复杂度 稳定性 选择排序 O(n²) O(n²) O(n²) O(1) 不稳定 插入排序 O(n²) O(n²) O(n) O(1) 稳定 冒泡排序 O(n²) O(n²) O(n) O(1) 稳定 快速排序 O(n log n) O(n²) O(n log n) O(log n) 不稳定 归并排序 O(n log n) O(n log n) O(n log n) O(n) 稳定 堆排序 O(n log n) O(n log n) O(n log n) O(1) 不稳定 总结 通过这次排序算法的实现和测试，我们可以得出以下结论：\n简单排序算法（选择、插入、冒泡）实现简单，但时间复杂度较高，适合小规模数据。\n高效排序算法（快速、归并、堆）时间复杂度较低，适合大规模数据处理。\n稳定性在某些应用场景中很重要，需要根据具体需求选择合适的算法。\n空间复杂度也是选择算法时需要考虑的重要因素。\n学习排序算法不仅仅是为了应付考试，更重要的是理解算法设计的思想和优化策略。每种算法都有其适用的场景，在实际开发中需要根据具体情况选择最合适的算法。\n代码质量的提升确实需要大量的练习和思考。虽然当时的代码可能不够完美，但这正是成长过程中的重要一步。\n","wordCount":"828","inLanguage":"en","image":"https://images.unsplash.com/photo-1518186285589-2f7649de83e0?w=800\u0026h=400\u0026fit=crop","datePublished":"2024-02-27T22:11:13+08:00","dateModified":"2025-08-06T08:51:21+08:00","author":{"@type":"Person","name":"tyhzxh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tyhzxh.github.io/posts/sorting-algorithms-implementation/"},"publisher":{"@type":"Organization","name":"tyhzxh的个人博客","logo":{"@type":"ImageObject","url":"https://tyhzxh.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tyhzxh.github.io/ accesskey=h title="tyhzxh的个人博客 (Alt + H)">tyhzxh的个人博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tyhzxh.github.io/ title=首页><span>首页</span></a></li><li><a href=https://tyhzxh.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://tyhzxh.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://tyhzxh.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://tyhzxh.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://tyhzxh.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tyhzxh.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://tyhzxh.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">经典排序算法实现与分析</h1><div class=post-description>详细介绍和实现经典排序算法，包括选择排序、插入排序、冒泡排序、快速排序、归并排序和堆排序，并提供性能测试代码</div><div class=post-meta><span title='2024-02-27 22:11:13 +0800 CST'>February 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;tyhzxh</div></header><figure class=entry-cover><img loading=eager src="https://images.unsplash.com/photo-1518186285589-2f7649de83e0?w=800&amp;h=400&amp;fit=crop" alt=排序算法可视化></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%b0%81%e8%a3%85 aria-label=基本数据结构封装>基本数据结构封装</a></li><li><a href=#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0 aria-label=排序算法实现>排序算法实现</a><ul><li><a href=#1-%e7%ae%80%e5%8d%95%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f aria-label="1. 简单选择排序">1. 简单选择排序</a></li><li><a href=#2-%e7%9b%b4%e6%8e%a5%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f aria-label="2. 直接插入排序">2. 直接插入排序</a></li><li><a href=#3-%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f aria-label="3. 冒泡排序">3. 冒泡排序</a></li><li><a href=#4-%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f aria-label="4. 快速排序">4. 快速排序</a></li><li><a href=#5-%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f aria-label="5. 归并排序">5. 归并排序</a></li><li><a href=#6-%e5%a0%86%e6%8e%92%e5%ba%8f aria-label="6. 堆排序">6. 堆排序</a></li></ul></li><li><a href=#%e6%b5%8b%e8%af%95%e6%a1%86%e6%9e%b6 aria-label=测试框架>测试框架</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=数据初始化>数据初始化</a></li><li><a href=#%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95%e5%87%bd%e6%95%b0 aria-label=性能测试函数>性能测试函数</a></li></ul></li><li><a href=#%e7%ae%97%e6%b3%95%e6%80%a7%e8%83%bd%e6%af%94%e8%be%83 aria-label=算法性能比较>算法性能比较</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div><div class=post-content><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>这是某次学校数据结构实验中实现的基本排序算法。数据结构这门课的难点在于实现的复杂性，每次实验都需要封装数据结构，编写测试程序，对于初学者来说确实是一个挑战。</p><p>通过这次实验，我深刻体会到了代码质量的重要性。虽然当时的代码可能不够优雅，但这正是学习过程中的宝贵经历。</p><h2 id=基本数据结构封装>基本数据结构封装<a hidden class=anchor aria-hidden=true href=#基本数据结构封装>#</a></h2><p>首先定义基本的数据结构和工具函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;stdio.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;ctime&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstdlib&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define ERROR 0
</span></span></span><span class=line><span class=cl><span class=cp>#define OK 1
</span></span></span><span class=line><span class=cl><span class=cp>#define Overflow 2
</span></span></span><span class=line><span class=cl><span class=cp>#define Underflow 3
</span></span></span><span class=line><span class=cl><span class=cp>#define NotPresent 4    </span><span class=c1>// 元素不存在
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define Duplicate 5     </span><span class=c1>// 元素重复存在
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define MaxSize 100001
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>KeyType</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>Status</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>DataType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>Entry</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>KeyType</span> <span class=n>key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DataType</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>entry</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>list</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Entry</span> <span class=n>D</span><span class=p>[</span><span class=n>MaxSize</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>List</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 输出函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Status</span> <span class=nf>printlist</span><span class=p>(</span><span class=n>list</span><span class=o>*</span> <span class=n>l</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%d &#34;</span><span class=p>,</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>OK</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 交换函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=n>Entry</span><span class=o>*</span> <span class=n>a</span><span class=p>,</span> <span class=n>Entry</span><span class=o>*</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Entry</span> <span class=n>temp</span> <span class=o>=</span> <span class=o>*</span><span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>a</span> <span class=o>=</span> <span class=o>*</span><span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>b</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=排序算法实现>排序算法实现<a hidden class=anchor aria-hidden=true href=#排序算法实现>#</a></h2><h3 id=1-简单选择排序>1. 简单选择排序<a hidden class=anchor aria-hidden=true href=#1-简单选择排序>#</a></h3><p>选择排序的基本思想是每次从未排序的元素中选择最小的元素，放到已排序序列的末尾。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Status</span> <span class=nf>choosesort</span><span class=p>(</span><span class=n>list</span><span class=o>*</span> <span class=n>l</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>min</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>n</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>min</span><span class=p>].</span><span class=n>key</span> <span class=o>&gt;</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>min</span> <span class=o>=</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>swap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>min</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>OK</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>时间复杂度</strong>：O(n²)<br><strong>空间复杂度</strong>：O(1)<br><strong>稳定性</strong>：不稳定</p><h3 id=2-直接插入排序>2. 直接插入排序<a hidden class=anchor aria-hidden=true href=#2-直接插入排序>#</a></h3><p>插入排序的基本思想是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Status</span> <span class=nf>insertsort</span><span class=p>(</span><span class=n>list</span><span class=o>*</span> <span class=n>l</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Entry</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=p>(</span><span class=n>j</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>key</span> <span class=o>&gt;</span> <span class=n>temp</span><span class=p>.</span><span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>OK</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>时间复杂度</strong>：O(n²)<br><strong>空间复杂度</strong>：O(1)<br><strong>稳定性</strong>：稳定</p><h3 id=3-冒泡排序>3. 冒泡排序<a hidden class=anchor aria-hidden=true href=#3-冒泡排序>#</a></h3><p>冒泡排序是一种简单的排序算法，它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Bubblesort</span><span class=p>(</span><span class=n>list</span><span class=o>*</span> <span class=n>l</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>start</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>end</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>end</span> <span class=o>&lt;</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>start</span><span class=p>].</span><span class=n>key</span> <span class=o>&gt;</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>end</span><span class=p>].</span><span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>Entry</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>start</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>start</span><span class=p>]</span> <span class=o>=</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>end</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>end</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=o>++</span><span class=n>start</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=o>++</span><span class=n>end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>时间复杂度</strong>：O(n²)<br><strong>空间复杂度</strong>：O(1)<br><strong>稳定性</strong>：稳定</p><h3 id=4-快速排序>4. 快速排序<a hidden class=anchor aria-hidden=true href=#4-快速排序>#</a></h3><p>快速排序使用分治法策略来把一个序列分为较小和较大的2个子序列，然后递归地排序两个子序列。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>QuickSort</span><span class=p>(</span><span class=n>List</span><span class=o>*</span> <span class=n>l</span><span class=p>,</span> <span class=kt>int</span> <span class=n>low</span><span class=p>,</span> <span class=kt>int</span> <span class=n>high</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>low</span> <span class=o>&lt;</span> <span class=n>high</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>low</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>high</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Entry</span> <span class=n>pivot</span> <span class=o>=</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>low</span><span class=p>];</span> <span class=c1>// 选择第一个元素作为基准
</span></span></span><span class=line><span class=cl><span class=c1></span>        
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 从右向左找小于基准的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>j</span> <span class=o>&amp;&amp;</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>key</span> <span class=o>&gt;</span> <span class=n>pivot</span><span class=p>.</span><span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>j</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>i</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>            <span class=c1>// 从左向右找大于基准的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>while</span><span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>j</span> <span class=o>&amp;&amp;</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>key</span> <span class=o>&lt;</span> <span class=n>pivot</span><span class=p>.</span><span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>j</span><span class=o>--</span><span class=p>]</span> <span class=o>=</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>pivot</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>QuickSort</span><span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>   <span class=c1>// 递归排序左半部分
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>QuickSort</span><span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>high</span><span class=p>);</span> <span class=c1>// 递归排序右半部分
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>时间复杂度</strong>：平均O(n log n)，最坏O(n²)<br><strong>空间复杂度</strong>：O(log n)<br><strong>稳定性</strong>：不稳定</p><blockquote><p>快速排序确实很精妙，理解和记忆都需要时间。它的核心思想是分治法，通过选择一个基准元素，将数组分为两部分，然后递归地对两部分进行排序。</p></blockquote><h3 id=5-归并排序>5. 归并排序<a hidden class=anchor aria-hidden=true href=#5-归并排序>#</a></h3><p>归并排序采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>merge</span><span class=p>(</span><span class=n>list</span><span class=o>*</span> <span class=n>l</span><span class=p>,</span> <span class=kt>int</span> <span class=n>left</span><span class=p>,</span> <span class=kt>int</span> <span class=n>lmid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>rmid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>left</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=n>rmid</span><span class=p>;</span> <span class=c1>// i,j指向left和right
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>list</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 合并两个有序序列
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span><span class=p>(</span><span class=n>i</span> <span class=o>&lt;=</span> <span class=n>lmid</span> <span class=o>&amp;&amp;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>key</span> <span class=o>&lt;=</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>temp</span><span class=p>.</span><span class=n>D</span><span class=p>[</span><span class=n>index</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>i</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>temp</span><span class=p>.</span><span class=n>D</span><span class=p>[</span><span class=n>index</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>j</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 复制剩余元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span><span class=p>(</span><span class=n>i</span> <span class=o>&lt;=</span> <span class=n>lmid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>temp</span><span class=p>.</span><span class=n>D</span><span class=p>[</span><span class=n>index</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>i</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>j</span> <span class=o>&lt;=</span> <span class=n>right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>temp</span><span class=p>.</span><span class=n>D</span><span class=p>[</span><span class=n>index</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>j</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 将临时数组的内容复制回原数组
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=n>left</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>right</span><span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>.</span><span class=n>D</span><span class=p>[</span><span class=n>n</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Status</span> <span class=nf>mergesort</span><span class=p>(</span><span class=n>list</span><span class=o>*</span> <span class=n>l</span><span class=p>,</span> <span class=kt>int</span> <span class=n>left</span><span class=p>,</span> <span class=kt>int</span> <span class=n>right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>left</span> <span class=o>&lt;</span> <span class=n>right</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>mid</span> <span class=o>=</span> <span class=n>left</span> <span class=o>+</span> <span class=p>(</span><span class=n>right</span> <span class=o>-</span> <span class=n>left</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>mergesort</span><span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>left</span><span class=p>,</span> <span class=n>mid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>mergesort</span><span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>merge</span><span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>left</span><span class=p>,</span> <span class=n>mid</span><span class=p>,</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>OK</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>时间复杂度</strong>：O(n log n)<br><strong>空间复杂度</strong>：O(n)<br><strong>稳定性</strong>：稳定</p><h3 id=6-堆排序>6. 堆排序<a hidden class=anchor aria-hidden=true href=#6-堆排序>#</a></h3><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>downadjust</span><span class=p>(</span><span class=n>list</span><span class=o>*</span> <span class=n>l</span><span class=p>,</span> <span class=kt>int</span> <span class=n>start</span><span class=p>,</span> <span class=kt>int</span> <span class=n>end</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Entry</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>start</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>start</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>end</span><span class=p>;</span> <span class=n>i</span> <span class=o>*=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 如果左子结点小于右子结点
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span><span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>end</span> <span class=o>&amp;&amp;</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>key</span> <span class=o>&gt;</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>].</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span><span class=o>++</span><span class=p>;</span> <span class=c1>// i指向右子结点
</span></span></span><span class=line><span class=cl><span class=c1></span>            
</span></span><span class=line><span class=cl>        <span class=c1>// 如果父结点大于子结点
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span><span class=p>(</span><span class=n>temp</span><span class=p>.</span><span class=n>key</span> <span class=o>&gt;=</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span> <span class=c1>// 调整结束
</span></span></span><span class=line><span class=cl><span class=c1></span>            
</span></span><span class=line><span class=cl>        <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>start</span><span class=p>]</span> <span class=o>=</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>i</span><span class=p>];</span> <span class=c1>// 否则将子结点值赋给父结点
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>start</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span> <span class=c1>// 重新赋值开始指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>start</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span> <span class=c1>// 调整结束后，将temp值放在最终位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Status</span> <span class=nf>heapsort</span><span class=p>(</span><span class=n>list</span><span class=o>*</span> <span class=n>l</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 建堆
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>n</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>downadjust</span><span class=p>(</span><span class=n>l</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>OK</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>时间复杂度</strong>：O(n log n)<br><strong>空间复杂度</strong>：O(1)<br><strong>稳定性</strong>：不稳定</p><h2 id=测试框架>测试框架<a hidden class=anchor aria-hidden=true href=#测试框架>#</a></h2><h3 id=数据初始化>数据初始化<a hidden class=anchor aria-hidden=true href=#数据初始化>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>list</span><span class=o>*</span> <span class=nf>initlist</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>list</span><span class=o>*</span> <span class=n>l</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>l</span> <span class=o>=</span> <span class=p>(</span><span class=n>list</span><span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>list</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>l</span><span class=o>-&gt;</span><span class=n>n</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>&gt;</span> <span class=n>MaxSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=n>srand</span><span class=p>(</span><span class=n>time</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span> <span class=c1>// 生成随机种子
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>key</span> <span class=o>=</span> <span class=p>(</span><span class=n>rand</span><span class=p>()</span> <span class=o>%</span> <span class=mi>1000</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// 随机数赋值
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>l</span><span class=o>-&gt;</span><span class=n>D</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>data</span> <span class=o>=</span> <span class=p>(</span><span class=n>rand</span><span class=p>()</span> <span class=o>%</span> <span class=mi>50</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>l</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>deletelist</span><span class=p>(</span><span class=n>list</span><span class=o>*</span> <span class=n>l</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>l</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>l</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=性能测试函数>性能测试函数<a hidden class=anchor aria-hidden=true href=#性能测试函数>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Status</span> <span class=nf>testchoosesort</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>list</span><span class=o>*</span> <span class=n>l0</span> <span class=o>=</span> <span class=n>initlist</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n\n</span><span class=s>make a new list!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printlist</span><span class=p>(</span><span class=n>l0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>clock_t</span> <span class=n>start</span><span class=p>,</span> <span class=n>finish</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>start</span> <span class=o>=</span> <span class=n>clock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>choosesort</span><span class=p>(</span><span class=n>l0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>finish</span> <span class=o>=</span> <span class=n>clock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>after choosesort</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printlist</span><span class=p>(</span><span class=n>l0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>TheTimes</span> <span class=o>=</span> <span class=p>(</span><span class=kt>double</span><span class=p>)(</span><span class=n>finish</span> <span class=o>-</span> <span class=n>start</span><span class=p>)</span> <span class=o>/</span> <span class=n>CLOCKS_PER_SEC</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;消耗%f秒。</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>TheTimes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>deletelist</span><span class=p>(</span><span class=n>l0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>OK</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Status</span> <span class=nf>testquicksort</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>list</span><span class=o>*</span> <span class=n>l0</span> <span class=o>=</span> <span class=n>initlist</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n\n</span><span class=s>make a new list!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printlist</span><span class=p>(</span><span class=n>l0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>clock_t</span> <span class=n>start</span><span class=p>,</span> <span class=n>finish</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>start</span> <span class=o>=</span> <span class=n>clock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>QuickSort</span><span class=p>(</span><span class=n>l0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>l0</span><span class=o>-&gt;</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>finish</span> <span class=o>=</span> <span class=n>clock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>after quicksort</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printlist</span><span class=p>(</span><span class=n>l0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>TheTimes</span> <span class=o>=</span> <span class=p>(</span><span class=kt>double</span><span class=p>)(</span><span class=n>finish</span> <span class=o>-</span> <span class=n>start</span><span class=p>)</span> <span class=o>/</span> <span class=n>CLOCKS_PER_SEC</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;消耗%f秒。</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>TheTimes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>deletelist</span><span class=p>(</span><span class=n>l0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>OK</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 主测试函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;测试不同规模数据的排序性能：</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>testinsertsort</span><span class=p>(</span><span class=mi>500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>testchoosesort</span><span class=p>(</span><span class=mi>500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>testBubblesort</span><span class=p>(</span><span class=mi>500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>testquicksort</span><span class=p>(</span><span class=mi>500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>testmergesort</span><span class=p>(</span><span class=mi>500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=算法性能比较>算法性能比较<a hidden class=anchor aria-hidden=true href=#算法性能比较>#</a></h2><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>最好时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>插入排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n)</td><td>O(1)</td><td>稳定</td></tr><tr><td>冒泡排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n)</td><td>O(1)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(n log n)</td><td>O(n²)</td><td>O(n log n)</td><td>O(log n)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n)</td><td>稳定</td></tr><tr><td>堆排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(1)</td><td>不稳定</td></tr></tbody></table><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>通过这次排序算法的实现和测试，我们可以得出以下结论：</p><ol><li><p><strong>简单排序算法</strong>（选择、插入、冒泡）实现简单，但时间复杂度较高，适合小规模数据。</p></li><li><p><strong>高效排序算法</strong>（快速、归并、堆）时间复杂度较低，适合大规模数据处理。</p></li><li><p><strong>稳定性</strong>在某些应用场景中很重要，需要根据具体需求选择合适的算法。</p></li><li><p><strong>空间复杂度</strong>也是选择算法时需要考虑的重要因素。</p></li></ol><p>学习排序算法不仅仅是为了应付考试，更重要的是理解算法设计的思想和优化策略。每种算法都有其适用的场景，在实际开发中需要根据具体情况选择最合适的算法。</p><blockquote><p>代码质量的提升确实需要大量的练习和思考。虽然当时的代码可能不够完美，但这正是成长过程中的重要一步。</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://tyhzxh.github.io/tags/%E7%AE%97%E6%B3%95/>算法</a></li><li><a href=https://tyhzxh.github.io/tags/%E6%8E%92%E5%BA%8F/>排序</a></li><li><a href=https://tyhzxh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a></li><li><a href=https://tyhzxh.github.io/tags/c++/>C++</a></li><li><a href=https://tyhzxh.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/>算法分析</a></li></ul><nav class=paginav><a class=prev href=https://tyhzxh.github.io/posts/http-protocol-guide/><span class=title>« Prev</span><br><span>HTTP协议详解：从基础到高级应用</span>
</a><a class=next href=https://tyhzxh.github.io/posts/dynamic-programming-guide/><span class=title>Next »</span><br><span>动态规划完全攻略：从入门到精通</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 经典排序算法实现与分析 on x" href="https://x.com/intent/tweet/?text=%e7%bb%8f%e5%85%b8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0%e4%b8%8e%e5%88%86%e6%9e%90&amp;url=https%3a%2f%2ftyhzxh.github.io%2fposts%2fsorting-algorithms-implementation%2f&amp;hashtags=%e7%ae%97%e6%b3%95%2c%e6%8e%92%e5%ba%8f%2c%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%2cC%2b%2b%2c%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 经典排序算法实现与分析 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ftyhzxh.github.io%2fposts%2fsorting-algorithms-implementation%2f&amp;title=%e7%bb%8f%e5%85%b8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0%e4%b8%8e%e5%88%86%e6%9e%90&amp;summary=%e7%bb%8f%e5%85%b8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0%e4%b8%8e%e5%88%86%e6%9e%90&amp;source=https%3a%2f%2ftyhzxh.github.io%2fposts%2fsorting-algorithms-implementation%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 经典排序算法实现与分析 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2ftyhzxh.github.io%2fposts%2fsorting-algorithms-implementation%2f&title=%e7%bb%8f%e5%85%b8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0%e4%b8%8e%e5%88%86%e6%9e%90"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 经典排序算法实现与分析 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ftyhzxh.github.io%2fposts%2fsorting-algorithms-implementation%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 经典排序算法实现与分析 on whatsapp" href="https://api.whatsapp.com/send?text=%e7%bb%8f%e5%85%b8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0%e4%b8%8e%e5%88%86%e6%9e%90%20-%20https%3a%2f%2ftyhzxh.github.io%2fposts%2fsorting-algorithms-implementation%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 经典排序算法实现与分析 on telegram" href="https://telegram.me/share/url?text=%e7%bb%8f%e5%85%b8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0%e4%b8%8e%e5%88%86%e6%9e%90&amp;url=https%3a%2f%2ftyhzxh.github.io%2fposts%2fsorting-algorithms-implementation%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 经典排序算法实现与分析 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e7%bb%8f%e5%85%b8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0%e4%b8%8e%e5%88%86%e6%9e%90&u=https%3a%2f%2ftyhzxh.github.io%2fposts%2fsorting-algorithms-implementation%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tyhzxh.github.io/>tyhzxh的个人博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>