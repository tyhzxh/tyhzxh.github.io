<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | tyhzxh的个人博客</title><meta name=keywords content><meta name=description content="Posts - tyhzxh的个人博客"><meta name=author content="tyhzxh"><link rel=canonical href=https://tyhzxh.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.8ee78296343cf29844826f6d943ca1b6638fc5059dcdf673ace996a7617f1b69.css integrity="sha256-jueCljQ88phEgm9tlDyhtmOPxQWdzfZzrOmWp2F/G2k=" rel="preload stylesheet" as=style><link rel=icon href=https://tyhzxh.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tyhzxh.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tyhzxh.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tyhzxh.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tyhzxh.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://tyhzxh.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://tyhzxh.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://tyhzxh.github.io/posts/"><meta property="og:site_name" content="tyhzxh的个人博客"><meta property="og:title" content="Posts"><meta property="og:description" content="分享技术、思考与生活的个人博客"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="分享技术、思考与生活的个人博客"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tyhzxh.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tyhzxh.github.io/ accesskey=h title="tyhzxh的个人博客 (Alt + H)">tyhzxh的个人博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tyhzxh.github.io/ title=首页><span>首页</span></a></li><li><a href=https://tyhzxh.github.io/posts/ title=文章><span class=active>文章</span></a></li><li><a href=https://tyhzxh.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://tyhzxh.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://tyhzxh.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://tyhzxh.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://tyhzxh.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><figure class=entry-cover><img loading=lazy src="https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&amp;h=400&amp;fit=crop" alt=HTTP协议与Web通信></figure><header class=entry-header><h2 class=entry-hint-parent>HTTP协议详解：从基础到高级应用</h2></header><div class=entry-content><p>HTTP协议概述 **HTTP（HyperText Transfer Protocol）**是互联网上应用最广泛的网络协议之一，是Web的基础。它定义了客户端和服务器之间如何进行通信，是一个基于请求-响应模式的、无状态的应用层协议。
HTTP的核心特点 特点 描述 影响 无状态 每个请求都是独立的 需要额外机制保持状态 无连接 请求完成后断开连接 HTTP/1.1引入持久连接 简单快速 协议简单，处理速度快 易于实现和调试 灵活 支持多种数据类型 可传输任意类型数据 HTTP协议版本演进 HTTP/1.0 vs HTTP/1.1 vs HTTP/2 vs HTTP/3 # HTTP版本特性对比 http_versions = { "HTTP/1.0": { "发布年份": 1996, "主要特性": [ "基本的请求-响应机制", "支持GET、POST、HEAD方法", "每个请求建立新连接" ], "缺点": ["连接开销大", "无法复用连接"] }, "HTTP/1.1": { "发布年份": 1997, "主要特性": [ "持久连接（Keep-Alive）", "管道化（Pipelining）", "分块传输编码", "Host头字段", "更多HTTP方法" ], "改进": ["减少连接开销", "支持虚拟主机"] }, "HTTP/2": { "发布年份": 2015, "主要特性": [ "二进制分帧", "多路复用", "头部压缩（HPACK）", "服务器推送", "流优先级" ], "性能提升": ["解决队头阻塞", "减少延迟"] }, "HTTP/3": { "发布年份": 2022, "主要特性": [ "基于QUIC协议", "UDP传输", "内置加密", "连接迁移", "0-RTT连接建立" ], "优势": ["更快的连接建立", "更好的移动网络支持"] } } for version, details in http_versions.items(): print(f"\n{version} ({details['发布年份']}年):") for feature in details.get('主要特性', []): print(f" • {feature}") HTTP请求和响应结构 HTTP请求结构 GET /api/users/123 HTTP/1.1 Host: api.example.com User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Accept: application/json Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9... Content-Type: application/json Content-Length: 85 { "name": "张三", "email": "zhangsan@example.com" } 请求结构解析 class HTTPRequest: """HTTP请求结构解析""" def __init__(self, raw_request): self.raw_request = raw_request self.parse_request() def parse_request(self): """解析HTTP请求""" lines = self.raw_request.strip().split('\n') # 解析请求行 request_line = lines[0] self.method, self.path, self.version = request_line.split(' ') # 解析请求头 self.headers = {} body_start = 1 for i, line in enumerate(lines[1:], 1): if line.strip() == '': body_start = i + 1 break if ':' in line: key, value = line.split(':', 1) self.headers[key.strip()] = value.strip() # 解析请求体 if body_start &lt; len(lines): self.body = '\n'.join(lines[body_start:]) else: self.body = '' def get_info(self): """获取请求信息""" return { "method": self.method, "path": self.path, "version": self.version, "headers": self.headers, "body": self.body } # 示例使用 sample_request = """GET /api/users HTTP/1.1 Host: api.example.com User-Agent: Mozilla/5.0 Accept: application/json """ request = HTTPRequest(sample_request) print("请求信息:", request.get_info()) HTTP响应结构 HTTP/1.1 200 OK Date: Mon, 27 Feb 2024 10:15:30 GMT Server: nginx/1.18.0 Content-Type: application/json; charset=utf-8 Content-Length: 156 Cache-Control: max-age=3600 ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4" Access-Control-Allow-Origin: * { "id": 123, "name": "张三", "email": "zhangsan@example.com", "created_at": "2024-02-27T10:15:30Z", "status": "active" } 响应结构解析 class HTTPResponse: """HTTP响应结构解析""" def __init__(self, raw_response): self.raw_response = raw_response self.parse_response() def parse_response(self): """解析HTTP响应""" lines = self.raw_response.strip().split('\n') # 解析状态行 status_line = lines[0] parts = status_line.split(' ', 2) self.version = parts[0] self.status_code = int(parts[1]) self.reason_phrase = parts[2] if len(parts) > 2 else '' # 解析响应头 self.headers = {} body_start = 1 for i, line in enumerate(lines[1:], 1): if line.strip() == '': body_start = i + 1 break if ':' in line: key, value = line.split(':', 1) self.headers[key.strip()] = value.strip() # 解析响应体 if body_start &lt; len(lines): self.body = '\n'.join(lines[body_start:]) else: self.body = '' def is_success(self): """判断是否成功响应""" return 200 &lt;= self.status_code &lt; 300 def get_info(self): """获取响应信息""" return { "version": self.version, "status_code": self.status_code, "reason_phrase": self.reason_phrase, "headers": self.headers, "body": self.body, "is_success": self.is_success() } HTTP方法详解 常用HTTP方法 class HTTPMethods: """HTTP方法详解和示例""" @staticmethod def get_method_info(): """获取HTTP方法信息""" methods = { "GET": { "用途": "获取资源", "特点": ["安全", "幂等", "可缓存"], "示例": "GET /api/users/123" }, "POST": { "用途": "创建资源或提交数据", "特点": ["不安全", "非幂等", "不可缓存"], "示例": "POST /api/users" }, "PUT": { "用途": "更新或创建资源", "特点": ["不安全", "幂等", "不可缓存"], "示例": "PUT /api/users/123" }, "DELETE": { "用途": "删除资源", "特点": ["不安全", "幂等", "不可缓存"], "示例": "DELETE /api/users/123" }, "PATCH": { "用途": "部分更新资源", "特点": ["不安全", "非幂等", "不可缓存"], "示例": "PATCH /api/users/123" }, "HEAD": { "用途": "获取资源头信息", "特点": ["安全", "幂等", "可缓存"], "示例": "HEAD /api/users/123" }, "OPTIONS": { "用途": "获取服务器支持的方法", "特点": ["安全", "幂等", "不可缓存"], "示例": "OPTIONS /api/users" } } return methods # RESTful API设计示例 class RESTfulAPI: """RESTful API设计示例""" def __init__(self): self.users = {} self.next_id = 1 def handle_request(self, method, path, data=None): """处理HTTP请求""" if path.startswith('/api/users'): if method == 'GET': if path == '/api/users': return self.get_users() else: user_id = self.extract_id(path) return self.get_user(user_id) elif method == 'POST' and path == '/api/users': return self.create_user(data) elif method == 'PUT': user_id = self.extract_id(path) return self.update_user(user_id, data) elif method == 'DELETE': user_id = self.extract_id(path) return self.delete_user(user_id) elif method == 'PATCH': user_id = self.extract_id(path) return self.patch_user(user_id, data) return {"error": "Not Found", "status": 404} def extract_id(self, path): """从路径中提取ID""" parts = path.split('/') return int(parts[-1]) if parts[-1].isdigit() else None def get_users(self): """获取所有用户""" return {"users": list(self.users.values()), "status": 200} def get_user(self, user_id): """获取单个用户""" if user_id in self.users: return {"user": self.users[user_id], "status": 200} return {"error": "User not found", "status": 404} def create_user(self, data): """创建用户""" user_id = self.next_id self.next_id += 1 user = { "id": user_id, "name": data.get("name"), "email": data.get("email"), "created_at": "2024-02-27T10:15:30Z" } self.users[user_id] = user return {"user": user, "status": 201} def update_user(self, user_id, data): """更新用户（完整替换）""" user = { "id": user_id, "name": data.get("name"), "email": data.get("email"), "updated_at": "2024-02-27T10:15:30Z" } self.users[user_id] = user return {"user": user, "status": 200} def patch_user(self, user_id, data): """部分更新用户""" if user_id not in self.users: return {"error": "User not found", "status": 404} user = self.users[user_id].copy() user.update(data) user["updated_at"] = "2024-02-27T10:15:30Z" self.users[user_id] = user return {"user": user, "status": 200} def delete_user(self, user_id): """删除用户""" if user_id in self.users: del self.users[user_id] return {"message": "User deleted", "status": 204} return {"error": "User not found", "status": 404} # 示例使用 api = RESTfulAPI() # 创建用户 result = api.handle_request('POST', '/api/users', { "name": "张三", "email": "zhangsan@example.com" }) print("创建用户:", result) # 获取用户 result = api.handle_request('GET', '/api/users/1') print("获取用户:", result) # 更新用户 result = api.handle_request('PATCH', '/api/users/1', { "name": "张三丰" }) print("更新用户:", result) HTTP状态码详解 状态码分类和含义 class HTTPStatusCodes: """HTTP状态码详解""" def __init__(self): self.status_codes = { # 1xx 信息性状态码 100: {"name": "Continue", "description": "继续请求"}, 101: {"name": "Switching Protocols", "description": "切换协议"}, 102: {"name": "Processing", "description": "处理中"}, # 2xx 成功状态码 200: {"name": "OK", "description": "请求成功"}, 201: {"name": "Created", "description": "资源已创建"}, 202: {"name": "Accepted", "description": "请求已接受"}, 204: {"name": "No Content", "description": "无内容"}, 206: {"name": "Partial Content", "description": "部分内容"}, # 3xx 重定向状态码 301: {"name": "Moved Permanently", "description": "永久重定向"}, 302: {"name": "Found", "description": "临时重定向"}, 304: {"name": "Not Modified", "description": "未修改"}, 307: {"name": "Temporary Redirect", "description": "临时重定向"}, 308: {"name": "Permanent Redirect", "description": "永久重定向"}, # 4xx 客户端错误状态码 400: {"name": "Bad Request", "description": "请求错误"}, 401: {"name": "Unauthorized", "description": "未授权"}, 403: {"name": "Forbidden", "description": "禁止访问"}, 404: {"name": "Not Found", "description": "资源未找到"}, 405: {"name": "Method Not Allowed", "description": "方法不允许"}, 409: {"name": "Conflict", "description": "冲突"}, 422: {"name": "Unprocessable Entity", "description": "无法处理的实体"}, 429: {"name": "Too Many Requests", "description": "请求过多"}, # 5xx 服务器错误状态码 500: {"name": "Internal Server Error", "description": "服务器内部错误"}, 501: {"name": "Not Implemented", "description": "未实现"}, 502: {"name": "Bad Gateway", "description": "网关错误"}, 503: {"name": "Service Unavailable", "description": "服务不可用"}, 504: {"name": "Gateway Timeout", "description": "网关超时"}, } def get_status_info(self, code): """获取状态码信息""" if code in self.status_codes: return self.status_codes[code] return {"name": "Unknown", "description": "未知状态码"} def get_category(self, code): """获取状态码类别""" if 100 &lt;= code &lt; 200: return "信息性响应" elif 200 &lt;= code &lt; 300: return "成功响应" elif 300 &lt;= code &lt; 400: return "重定向" elif 400 &lt;= code &lt; 500: return "客户端错误" elif 500 &lt;= code &lt; 600: return "服务器错误" else: return "未知类别" def is_error(self, code): """判断是否为错误状态码""" return code >= 400 # 状态码使用示例 def handle_api_response(status_code, data=None): """处理API响应""" status_handler = HTTPStatusCodes() info = status_handler.get_status_info(status_code) category = status_handler.get_category(status_code) response = { "status_code": status_code, "status_name": info["name"], "description": info["description"], "category": category, "is_error": status_handler.is_error(status_code) } if data: response["data"] = data return response # 示例使用 print("成功响应:", handle_api_response(200, {"message": "操作成功"})) print("客户端错误:", handle_api_response(404)) print("服务器错误:", handle_api_response(500)) HTTP头字段详解 常用请求头 class HTTPHeaders: """HTTP头字段详解""" def __init__(self): self.request_headers = { "Accept": { "用途": "指定客户端能够接收的内容类型", "示例": "Accept: application/json, text/html", "重要性": "高" }, "Accept-Encoding": { "用途": "指定客户端支持的编码格式", "示例": "Accept-Encoding: gzip, deflate, br", "重要性": "中" }, "Accept-Language": { "用途": "指定客户端偏好的语言", "示例": "Accept-Language: zh-CN,zh;q=0.9,en;q=0.8", "重要性": "中" }, "Authorization": { "用途": "包含认证凭据", "示例": "Authorization: Bearer eyJhbGciOiJIUzI1NiIs...", "重要性": "高" }, "Cache-Control": { "用途": "指定缓存机制", "示例": "Cache-Control: no-cache, max-age=0", "重要性": "高" }, "Content-Type": { "用途": "指定请求体的媒体类型", "示例": "Content-Type: application/json; charset=utf-8", "重要性": "高" }, "Cookie": { "用途": "发送存储的Cookie", "示例": "Cookie: sessionid=abc123; csrftoken=xyz789", "重要性": "高" }, "Host": { "用途": "指定服务器的域名和端口", "示例": "Host: api.example.com:443", "重要性": "必需" }, "Referer": { "用途": "指定请求来源页面", "示例": "Referer: https://example.com/page", "重要性": "中" }, "User-Agent": { "用途": "标识客户端应用程序", "示例": "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)", "重要性": "中" } } self.response_headers = { "Access-Control-Allow-Origin": { "用途": "CORS跨域访问控制", "示例": "Access-Control-Allow-Origin: *", "重要性": "高" }, "Cache-Control": { "用途": "指定缓存策略", "示例": "Cache-Control: public, max-age=3600", "重要性": "高" }, "Content-Encoding": { "用途": "指定内容编码格式", "示例": "Content-Encoding: gzip", "重要性": "中" }, "Content-Length": { "用途": "指定响应体长度", "示例": "Content-Length: 1024", "重要性": "高" }, "Content-Type": { "用途": "指定响应体的媒体类型", "示例": "Content-Type: application/json; charset=utf-8", "重要性": "高" }, "ETag": { "用途": "资源的唯一标识符", "示例": "ETag: \"33a64df551425fcc55e4d42a148795d9f25f89d4\"", "重要性": "中" }, "Expires": { "用途": "指定资源过期时间", "示例": "Expires: Wed, 21 Oct 2024 07:28:00 GMT", "重要性": "中" }, "Last-Modified": { "用途": "资源最后修改时间", "示例": "Last-Modified: Wed, 21 Oct 2024 07:28:00 GMT", "重要性": "中" }, "Location": { "用途": "重定向的目标URL", "示例": "Location: https://example.com/new-page", "重要性": "高" }, "Set-Cookie": { "用途": "设置Cookie", "示例": "Set-Cookie: sessionid=abc123; HttpOnly; Secure", "重要性": "高" } } # 头字段处理示例 class HeaderProcessor: """HTTP头字段处理器""" def __init__(self): self.headers = {} def add_header(self, name, value): """添加头字段""" self.headers[name] = value def get_content_type(self): """获取内容类型""" content_type = self.headers.get('Content-Type', '') if ';' in content_type: return content_type.split(';')[0].strip() return content_type def get_charset(self): """获取字符编码""" content_type = self.headers.get('Content-Type', '') if 'charset=' in content_type: return content_type.split('charset=')[1].strip() return 'utf-8' def is_json(self): """判断是否为JSON格式""" return self.get_content_type() == 'application/json' def get_cache_control(self): """解析Cache-Control头""" cache_control = self.headers.get('Cache-Control', '') directives = {} for directive in cache_control.split(','): directive = directive.strip() if '=' in directive: key, value = directive.split('=', 1) directives[key.strip()] = value.strip() else: directives[directive] = True return directives def get_authorization_type(self): """获取认证类型""" auth = self.headers.get('Authorization', '') if auth: return auth.split(' ')[0] return None # 示例使用 processor = HeaderProcessor() processor.add_header('Content-Type', 'application/json; charset=utf-8') processor.add_header('Cache-Control', 'public, max-age=3600, must-revalidate') processor.add_header('Authorization', 'Bearer eyJhbGciOiJIUzI1NiIs...') print("内容类型:", processor.get_content_type()) print("字符编码:", processor.get_charset()) print("是否JSON:", processor.is_json()) print("缓存控制:", processor.get_cache_control()) print("认证类型:", processor.get_authorization_type()) HTTP缓存机制 缓存策略详解 import hashlib import time from datetime import datetime, timedelta class HTTPCache: """HTTP缓存机制实现""" def __init__(self): self.cache = {} def generate_etag(self, content): """生成ETag""" return hashlib.md5(content.encode()).hexdigest() def is_fresh(self, cache_entry): """检查缓存是否新鲜""" if 'expires' in cache_entry: return datetime.now() &lt; cache_entry['expires'] if 'max_age' in cache_entry: age = datetime.now() - cache_entry['cached_at'] return age.total_seconds() &lt; cache_entry['max_age'] return False def handle_cache_request(self, url, headers=None): """处理缓存请求""" if headers is None: headers = {} cache_entry = self.cache.get(url) # 检查是否有缓存 if not cache_entry: return {"cache_status": "MISS", "should_fetch": True} # 检查缓存是否新鲜 if not self.is_fresh(cache_entry): return {"cache_status": "STALE", "should_fetch": True} # 检查条件请求 if 'If-None-Match' in headers: if headers['If-None-Match'] == cache_entry.get('etag'): return {"cache_status": "NOT_MODIFIED", "should_fetch": False} if 'If-Modified-Since' in headers: if_modified = datetime.strptime(headers['If-Modified-Since'], '%a, %d %b %Y %H:%M:%S GMT') if cache_entry.get('last_modified') and if_modified >= cache_entry['last_modified']: return {"cache_status": "NOT_MODIFIED", "should_fetch": False} return {"cache_status": "HIT", "should_fetch": False, "data": cache_entry['data']} def store_response(self, url, response_data, headers): """存储响应到缓存""" cache_entry = { "data": response_data, "cached_at": datetime.now(), "headers": headers } # 处理ETag if 'ETag' in headers: cache_entry['etag'] = headers['ETag'] # 处理Last-Modified if 'Last-Modified' in headers: cache_entry['last_modified'] = datetime.strptime( headers['Last-Modified'], '%a, %d %b %Y %H:%M:%S GMT' ) # 处理Expires if 'Expires' in headers: cache_entry['expires'] = datetime.strptime( headers['Expires'], '%a, %d %b %Y %H:%M:%S GMT' ) # 处理Cache-Control if 'Cache-Control' in headers: cache_control = self.parse_cache_control(headers['Cache-Control']) if 'max-age' in cache_control: cache_entry['max_age'] = int(cache_control['max-age']) if 'no-cache' in cache_control or 'no-store' in cache_control: return # 不缓存 self.cache[url] = cache_entry def parse_cache_control(self, cache_control_header): """解析Cache-Control头""" directives = {} for directive in cache_control_header.split(','): directive = directive.strip() if '=' in directive: key, value = directive.split('=', 1) directives[key.strip()] = value.strip() else: directives[directive] = True return directives # 缓存策略示例 class CacheStrategy: """缓存策略示例""" @staticmethod def get_cache_headers(resource_type, max_age=3600): """根据资源类型获取缓存头""" strategies = { "static": { "Cache-Control": f"public, max-age={max_age * 24 * 365}", # 1年 "Expires": (datetime.now() + timedelta(days=365)).strftime( '%a, %d %b %Y %H:%M:%S GMT' ) }, "api": { "Cache-Control": f"private, max-age={max_age}", # 1小时 "ETag": '"' + hashlib.md5(str(time.time()).encode()).hexdigest() + '"' }, "dynamic": { "Cache-Control": "no-cache, must-revalidate", "Pragma": "no-cache" }, "sensitive": { "Cache-Control": "no-store, no-cache, must-revalidate", "Pragma": "no-cache", "Expires": "0" } } return strategies.get(resource_type, strategies["dynamic"]) # 示例使用 cache = HTTPCache() # 模拟第一次请求 url = "https://api.example.com/users" result = cache.handle_cache_request(url) print("第一次请求:", result) # 存储响应 response_data = {"users": [{"id": 1, "name": "张三"}]} response_headers = { "Cache-Control": "public, max-age=3600", "ETag": '"abc123"', "Last-Modified": "Mon, 27 Feb 2024 10:15:30 GMT" } cache.store_response(url, response_data, response_headers) # 模拟第二次请求 result = cache.handle_cache_request(url) print("第二次请求:", result) # 模拟条件请求 conditional_headers = {"If-None-Match": '"abc123"'} result = cache.handle_cache_request(url, conditional_headers) print("条件请求:", result) HTTP安全机制 HTTPS和安全头 class HTTPSecurity: """HTTP安全机制""" def __init__(self): self.security_headers = { "Strict-Transport-Security": { "用途": "强制使用HTTPS", "示例": "Strict-Transport-Security: max-age=31536000; includeSubDomains", "防护": "中间人攻击" }, "Content-Security-Policy": { "用途": "防止XSS攻击", "示例": "Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'", "防护": "跨站脚本攻击" }, "X-Frame-Options": { "用途": "防止点击劫持", "示例": "X-Frame-Options: DENY", "防护": "点击劫持攻击" }, "X-Content-Type-Options": { "用途": "防止MIME类型嗅探", "示例": "X-Content-Type-Options: nosniff", "防护": "MIME嗅探攻击" }, "X-XSS-Protection": { "用途": "启用XSS过滤器", "示例": "X-XSS-Protection: 1; mode=block", "防护": "反射型XSS攻击" }, "Referrer-Policy": { "用途": "控制Referer头信息", "示例": "Referrer-Policy: strict-origin-when-cross-origin", "防护": "信息泄露" } } def get_security_headers(self, security_level="high"): """获取安全头配置""" if security_level == "high": return { "Strict-Transport-Security": "max-age=31536000; includeSubDomains; preload", "Content-Security-Policy": "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'", "X-Frame-Options": "DENY", "X-Content-Type-Options": "nosniff", "X-XSS-Protection": "1; mode=block", "Referrer-Policy": "strict-origin-when-cross-origin" } elif security_level == "medium": return { "Strict-Transport-Security": "max-age=31536000", "Content-Security-Policy": "default-src 'self' 'unsafe-inline'", "X-Frame-Options": "SAMEORIGIN", "X-Content-Type-Options": "nosniff" } else: return { "X-Content-Type-Options": "nosniff" } def validate_request(self, headers, body=None): """验证请求安全性""" issues = [] # 检查Content-Type if body and 'Content-Type' not in headers: issues.append("缺少Content-Type头") # 检查CSRF保护 if headers.get('Content-Type', '').startswith('application/json'): if 'X-Requested-With' not in headers and 'X-CSRF-Token' not in headers: issues.append("可能存在CSRF风险") # 检查认证 if 'Authorization' not in headers and 'Cookie' not in headers: issues.append("缺少认证信息") return { "is_secure": len(issues) == 0, "issues": issues } # CORS处理 class CORSHandler: """CORS跨域资源共享处理""" def __init__(self, allowed_origins=None, allowed_methods=None, allowed_headers=None): self.allowed_origins = allowed_origins or ['*'] self.allowed_methods = allowed_methods or ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'] self.allowed_headers = allowed_headers or ['Content-Type', 'Authorization', 'X-Requested-With'] def handle_preflight(self, origin, method, headers): """处理预检请求""" response_headers = {} # 检查来源 if self.is_origin_allowed(origin): response_headers['Access-Control-Allow-Origin'] = origin # 检查方法 if method in self.allowed_methods: response_headers['Access-Control-Allow-Methods'] = ', '.join(self.allowed_methods) # 检查头部 if headers: requested_headers = [h.strip() for h in headers.split(',')] allowed = [h for h in requested_headers if h in self.allowed_headers] if allowed: response_headers['Access-Control-Allow-Headers'] = ', '.join(allowed) response_headers['Access-Control-Max-Age'] = '86400' # 24小时 return response_headers def handle_actual_request(self, origin): """处理实际请求""" response_headers = {} if self.is_origin_allowed(origin): response_headers['Access-Control-Allow-Origin'] = origin response_headers['Access-Control-Allow-Credentials'] = 'true' return response_headers def is_origin_allowed(self, origin): """检查来源是否被允许""" return '*' in self.allowed_origins or origin in self.allowed_origins # 示例使用 security = HTTPSecurity() print("高安全级别头部:", security.get_security_headers("high")) # CORS示例 cors = CORSHandler( allowed_origins=['https://example.com', 'https://app.example.com'], allowed_methods=['GET', 'POST', 'PUT', 'DELETE'], allowed_headers=['Content-Type', 'Authorization'] ) preflight_headers = cors.handle_preflight( origin='https://example.com', method='POST', headers='Content-Type, Authorization' ) print("预检响应头:", preflight_headers) HTTP/2 和 HTTP/3 新特性 HTTP/2 特性 class HTTP2Features: """HTTP/2 特性演示""" def __init__(self): self.streams = {} self.next_stream_id = 1 def create_stream(self, method, path, headers=None): """创建HTTP/2流""" stream_id = self.next_stream_id self.next_stream_id += 2 # 客户端流ID为奇数 stream = { "id": stream_id, "method": method, "path": path, "headers": headers or {}, "state": "open", "priority": 16, # 默认优先级 "dependency": 0 } self.streams[stream_id] = stream return stream_id def set_priority(self, stream_id, priority, dependency=0): """设置流优先级""" if stream_id in self.streams: self.streams[stream_id]["priority"] = priority self.streams[stream_id]["dependency"] = dependency def server_push(self, parent_stream_id, path, headers=None): """服务器推送""" push_stream_id = self.next_stream_id + 1 self.next_stream_id += 2 push_stream = { "id": push_stream_id, "method": "GET", "path": path, "headers": headers or {}, "state": "reserved_local", "parent": parent_stream_id, "pushed": True } self.streams[push_stream_id] = push_stream return push_stream_id def compress_headers(self, headers): """HPACK头部压缩模拟""" # 简化的头部压缩示例 compressed_size = 0 static_table = { ":method": {"GET": 2, "POST": 3}, ":path": {"/": 4}, ":scheme": {"https": 7}, "content-type": {"application/json": 31} } for name, value in headers.items(): if name in static_table and value in static_table[name]: compressed_size += 1 # 索引引用 else: compressed_size += len(name) + len(value) # 字面量 original_size = sum(len(k) + len(v) for k, v in headers.items()) compression_ratio = compressed_size / original_size if original_size > 0 else 1 return { "original_size": original_size, "compressed_size": compressed_size, "compression_ratio": compression_ratio } # HTTP/3 特性 class HTTP3Features: """HTTP/3 特性演示""" def __init__(self): self.connections = {} self.connection_id = 0 def create_connection(self, server_name): """创建QUIC连接""" self.connection_id += 1 connection = { "id": self.connection_id, "server_name": server_name, "state": "handshaking", "streams": {}, "rtt": 0, "congestion_window": 10, "migration_capable": True } self.connections[self.connection_id] = connection return self.connection_id def zero_rtt_request(self, connection_id, method, path, early_data=None): """0-RTT请求""" if connection_id not in self.connections: return None connection = self.connections[connection_id] # 模拟0-RTT请求 request = { "method": method, "path": path, "early_data": early_data, "rtt": 0, # 0-RTT "timestamp": time.time() } return request def connection_migration(self, connection_id, new_address): """连接迁移""" if connection_id not in self.connections: return False connection = self.connections[connection_id] if connection["migration_capable"]: connection["address"] = new_address connection["migrated"] = True return True return False def get_performance_comparison(self): """性能对比""" return { "HTTP/1.1": { "连接建立": "3-RTT (TCP + TLS)", "多路复用": "无", "头部压缩": "无", "服务器推送": "无" }, "HTTP/2": { "连接建立": "3-RTT (TCP + TLS)", "多路复用": "有 (单连接)", "头部压缩": "HPACK", "服务器推送": "有" }, "HTTP/3": { "连接建立": "1-RTT (QUIC)", "多路复用": "有 (无队头阻塞)", "头部压缩": "QPACK", "服务器推送": "有", "连接迁移": "有", "0-RTT": "有" } } # 示例使用 http2 = HTTP2Features() # 创建多个流 stream1 = http2.create_stream("GET", "/api/users") stream2 = http2.create_stream("GET", "/api/posts") stream3 = http2.create_stream("GET", "/static/app.js") # 设置优先级 http2.set_priority(stream3, 8) # 静态资源优先级较低 # 服务器推送 push_stream = http2.server_push(stream1, "/static/style.css") # 头部压缩 headers = { ":method": "GET", ":path": "/api/users", ":scheme": "https", "content-type": "application/json" } compression_result = http2.compress_headers(headers) print("头部压缩结果:", compression_result) # HTTP/3示例 http3 = HTTP3Features() conn_id = http3.create_connection("api.example.com") # 0-RTT请求 zero_rtt_req = http3.zero_rtt_request(conn_id, "GET", "/api/users") print("0-RTT请求:", zero_rtt_req) # 性能对比 comparison = http3.get_performance_comparison() for version, features in comparison.items(): print(f"\n{version}:") for feature, value in features.items(): print(f" {feature}: {value}") 实际应用和最佳实践 Web API设计最佳实践 class WebAPIBestPractices: """Web API设计最佳实践""" def __init__(self): self.api_guidelines = { "URL设计": [ "使用名词而非动词", "使用复数形式", "保持URL简洁", "使用连字符分隔单词" ], "HTTP方法使用": [ "GET: 获取资源", "POST: 创建资源", "PUT: 完整更新资源", "PATCH: 部分更新资源", "DELETE: 删除资源" ], "状态码使用": [ "200: 成功", "201: 创建成功", "204: 无内容", "400: 请求错误", "401: 未授权", "403: 禁止访问", "404: 资源未找到", "500: 服务器错误" ], "响应格式": [ "使用JSON格式", "保持响应结构一致", "包含适当的元数据", "提供错误详情" ] } def design_api_response(self, data=None, error=None, meta=None): """设计API响应格式""" response = {} if error: response["success"] = False response["error"] = { "code": error.get("code", "UNKNOWN_ERROR"), "message": error.get("message", "An error occurred"), "details": error.get("details") } else: response["success"] = True response["data"] = data if meta: response["meta"] = meta response["timestamp"] = datetime.now().isoformat() return response def paginate_response(self, items, page=1, per_page=20, total=None): """分页响应""" start = (page - 1) * per_page end = start + per_page paginated_items = items[start:end] if total is None: total = len(items) total_pages = (total + per_page - 1) // per_page return self.design_api_response( data=paginated_items, meta={ "pagination": { "page": page, "per_page": per_page, "total": total, "total_pages": total_pages, "has_next": page &lt; total_pages, "has_prev": page > 1 } } ) def validate_request(self, request_data, required_fields=None): """请求验证""" errors = [] if required_fields: for field in required_fields: if field not in request_data: errors.append(f"缺少必需字段: {field}") elif not request_data[field]: errors.append(f"字段不能为空: {field}") return { "is_valid": len(errors) == 0, "errors": errors } # 性能优化建议 class HTTPPerformanceOptimization: """HTTP性能优化""" def __init__(self): self.optimization_techniques = { "缓存策略": [ "设置适当的Cache-Control头", "使用ETag进行条件请求", "实施CDN缓存", "使用浏览器缓存" ], "压缩技术": [ "启用Gzip/Brotli压缩", "压缩静态资源", "优化图片格式", "使用WebP格式" ], "连接优化": [ "使用HTTP/2或HTTP/3", "启用Keep-Alive", "减少DNS查询", "使用连接池" ], "请求优化": [ "减少HTTP请求数量", "合并CSS和JavaScript文件", "使用雪碧图", "延迟加载非关键资源" ] } def analyze_performance(self, response_time, response_size, cache_hit_ratio): """性能分析""" analysis = { "response_time": { "value": response_time, "status": "good" if response_time &lt; 200 else "needs_improvement" }, "response_size": { "value": response_size, "status": "good" if response_size &lt; 1024 * 1024 else "large" }, "cache_efficiency": { "hit_ratio": cache_hit_ratio, "status": "good" if cache_hit_ratio > 0.8 else "needs_improvement" } } recommendations = [] if response_time > 200: recommendations.append("考虑使用CDN或优化服务器响应时间") if response_size > 1024 * 1024: recommendations.append("启用压缩或优化响应内容") if cache_hit_ratio &lt; 0.8: recommendations.append("优化缓存策略") analysis["recommendations"] = recommendations return analysis # 示例使用 api = WebAPIBestPractices() # 设计成功响应 success_response = api.design_api_response( data={"id": 1, "name": "张三", "email": "zhangsan@example.com"} ) print("成功响应:", success_response) # 设计错误响应 error_response = api.design_api_response( error={ "code": "VALIDATION_ERROR", "message": "请求数据验证失败", "details": ["邮箱格式不正确", "密码长度不足"] } ) print("错误响应:", error_response) # 分页响应 users = [{"id": i, "name": f"用户{i}"} for i in range(1, 101)] paginated = api.paginate_response(users, page=2, per_page=10) print("分页响应:", paginated) # 性能分析 perf = HTTPPerformanceOptimization() analysis = perf.analyze_performance( response_time=150, # ms response_size=512 * 1024, # bytes cache_hit_ratio=0.75 ) print("性能分析:", analysis) 学习建议和总结 HTTP学习路径 基础概念：理解HTTP的工作原理和特点 协议细节：掌握请求响应格式、状态码、头字段 缓存机制：学习HTTP缓存策略和实现 安全机制：了解HTTPS、CORS、安全头等 性能优化：掌握HTTP性能优化技巧 新版本特性：学习HTTP/2和HTTP/3的新特性 关键要点总结 方面 要点 实践建议 请求方法 正确使用GET、POST、PUT、DELETE等 遵循RESTful设计原则 状态码 返回合适的HTTP状态码 提供清晰的错误信息 缓存 合理设置缓存策略 平衡性能和数据新鲜度 安全 实施适当的安全措施 使用HTTPS和安全头 性能 优化请求和响应 使用压缩和CDN 实际应用建议 API设计：遵循RESTful原则，保持接口一致性 错误处理：提供详细的错误信息和处理建议 文档化：维护完整的API文档 监控：实施性能监控和日志记录 版本控制：合理管理API版本 HTTP协议是Web开发的基础，深入理解其工作原理和最佳实践对于构建高质量的Web应用至关重要。随着HTTP/2和HTTP/3的普及，掌握新特性将有助于进一步提升应用性能。
...</p></div><footer class=entry-footer><span title='2024-02-28 10:15:00 +0800 CST'>February 28, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;tyhzxh</footer><a class=entry-link aria-label="post link to HTTP协议详解：从基础到高级应用" href=https://tyhzxh.github.io/posts/http-protocol-guide/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src="https://images.unsplash.com/photo-1518186285589-2f7649de83e0?w=800&amp;h=400&amp;fit=crop" alt=排序算法可视化></figure><header class=entry-header><h2 class=entry-hint-parent>经典排序算法实现与分析</h2></header><div class=entry-content><p>前言 这是某次学校数据结构实验中实现的基本排序算法。数据结构这门课的难点在于实现的复杂性，每次实验都需要封装数据结构，编写测试程序，对于初学者来说确实是一个挑战。
通过这次实验，我深刻体会到了代码质量的重要性。虽然当时的代码可能不够优雅，但这正是学习过程中的宝贵经历。
基本数据结构封装 首先定义基本的数据结构和工具函数：
#include "stdio.h" #include &lt;iostream> #include &lt;ctime> #include &lt;cstdlib> #define ERROR 0 #define OK 1 #define Overflow 2 #define Underflow 3 #define NotPresent 4 // 元素不存在 #define Duplicate 5 // 元素重复存在 #define MaxSize 100001 typedef int KeyType; typedef int Status; typedef int DataType; typedef struct Entry { KeyType key; DataType data; } entry; typedef struct list { int n; Entry D[MaxSize]; } List; // 输出函数 Status printlist(list* l) { for(int i = 0; i &lt; l->n; i++) { printf("%d ", l->D[i].key); } return OK; } // 交换函数 void swap(Entry* a, Entry* b) { Entry temp = *a; *a = *b; *b = temp; } 排序算法实现 1. 简单选择排序 选择排序的基本思想是每次从未排序的元素中选择最小的元素，放到已排序序列的末尾。
...</p></div><footer class=entry-footer><span title='2024-02-27 22:11:13 +0800 CST'>February 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;tyhzxh</footer><a class=entry-link aria-label="post link to 经典排序算法实现与分析" href=https://tyhzxh.github.io/posts/sorting-algorithms-implementation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>动态规划完全攻略：从入门到精通</h2></header><div class=entry-content><p>今天开始！DP！针对动态规划（DP）的系统训练，这是一套完整的训练方案，从核心思维到高频题型再到实战技巧全面覆盖。
一、动态规划核心思维训练 1. 破除两大误区 ❌ 误区1：必须找到最优子结构才能用DP
✅ 正确姿势：先暴力递归 → 发现重叠子问题 → 改记忆化搜索 → 再推导DP方程
❌ 误区2：DP必须用数组存储状态
✅ 正确姿势：学会状态压缩（如打家劫舍用两个变量代替数组）
2. 四步解题法（用爬楼梯问题实践） # 原题：每次爬1或2阶，到n阶有多少种方法？ # 1. 定义状态：dp[i]表示到i阶的方法数 # 2. 初始状态：dp[0]=1, dp[1]=1（注意不是常规的dp[0]=0） # 3. 状态转移：dp[i] = dp[i-1] + dp[i-2] # 4. 优化空间：只需prev和curr两个变量滚动计算 def climbStairs(n): if n &lt;= 1: return 1 prev, curr = 1, 1 for i in range(2, n+1): prev, curr = curr, prev + curr return curr 3. 高频状态转移类型 类型 经典例题 状态转移关键点 单序列线性DP 打家劫舍(198) dp[i] = max(dp[i-1], dp[i-2]+nums[i]) 双序列匹配DP 最长公共子序列(1143) dp[i][j] = 1+dp[i-1][j-1] if s[i]==t[j] 区间DP 最长回文子串(5) dp[i][j] = (s[i]==s[j]) and dp[i+1][j-1] 背包DP 分割等和子集(416) dp[j] = dp[j] or dp[j-num] 状态机DP 买卖股票最佳时机(121/122) 持有/未持有两种状态转换 二、阶梯式训练路线 阶段1：基础模型搭建（1-2周） 题目 训练重点 突破技巧 70. 爬楼梯 斐波那契型DP 空间压缩到O(1) 118. 杨辉三角 二维DP填表逻辑 观察行列关系 121. 买卖股票的最佳时机 状态机模型 维护min_price和max_profit 53. 最大子数组和 决策型DP（选或不选） 用curr_max代替dp数组 746. 使用最小花费爬楼梯 路径成本计算 逆向推导更简单 阶段2：经典题型突破（2-3周） 题目 难点解析 代码模板片段 198. 打家劫舍 相邻不能选 max(dp[i-1], dp[i-2]+nums[i]) 322. 零钱兑换 完全背包最小值 dp[amt] = min(dp[amt], dp[amt-coin]+1) 300. 最长递增子序列 O(n²)与O(nlogn)两种解法 二分查找维护tails数组 1143. 最长公共子序列 双序列匹配 if s[i]==t[j]: dp[i][j]=dp[i-1][j-1]+1 139. 单词拆分 字符串分段判断 dp[i] = any(dp[j] and s[j:i] in dict) 阶段3：高难度挑战（3-4周） 题目 破题关键点 优化技巧 72. 编辑距离 三种操作的状态转移 空间压缩到一维数组 152. 乘积最大子数组 处理负数乘积 同时维护max和min 312. 戳气球 区间DP逆向思维 从最后戳破的气球倒推 10. 正则表达式匹配 星号匹配的特殊处理 分情况讨论pattern的第二个字符 887. 鸡蛋掉落 决策最优化的数学推导 逆向思维+二分查找优化 三、避坑指南与实战技巧 1. 五大常见错误类型 🚫 初始化错误：比如背包问题中dp[0]应该初始化为True 🚫 遍历顺序错误：完全背包要正序循环，01背包要倒序循环 🚫 状态转移遗漏：如编辑距离忘记考虑replace操作 🚫 二维DP行列混淆：把s的长度当作行还是列要统一 🚫 空间压缩陷阱：覆盖未使用的旧值导致错误 2. 三步优化方法论 1. **暴力递归** → 写出基本状态转移 - 斐波那契数列递归版 2. **记忆化搜索** → 添加缓存（@lru_cache） - 用装饰器自动缓存参数 3. **推导DP方程** → 优化空间复杂度 - 观察状态依赖关系，压缩维度 3. 面试应答技巧 💡 先说出暴力解的时间复杂度 💡 明确说出DP数组的定义和维度 💡 在白板上先写状态转移方程再编码 💡 主动讨论空间优化可能性 四、配套训练资源 1. 可视化学习 DPV 算法可视化网站 - 动态展示DP执行过程 VisuAlgo 动态规划专题 - 包含LCS、背包等问题动画 2. 专项题单 LeetCode动态规划分类 → 按通过率排序练习 经典DP问题Top 50 → 涵盖所有DP类型 3. 错题本模板 ## 72. 编辑距离 ### 错误记录 - 初始版本忘记处理空字符串情况 - 误将替换操作的成本计算为2（正确是1） ### 状态转移表 | | "" | r | o | s | |-------|----|---|---|---| | "" | 0 | 1 | 2 | 3 | | h | 1 | 1 | 2 | 3 | | o | 2 | 2 | 1 | 2 | | r | 3 | 2 | 2 | 2 | | s | 4 | 3 | 3 | 2 | 五、训练计划建议 每日任务 上午：精做1道新DP题（按阶段选择难度） 下午：复习2道旧题，写出空间优化版本 晚上：观看对应题目的讲解视频 每周检验 周赛至少完成2道DP相关题目 整理本周的DP类型思维导图 预期效果 坚持按照这个方案训练2个月后，你会明显发现：
...</p></div><footer class=entry-footer><span title='2024-02-27 22:05:43 +0800 CST'>February 27, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;tyhzxh</footer><a class=entry-link aria-label="post link to 动态规划完全攻略：从入门到精通" href=https://tyhzxh.github.io/posts/dynamic-programming-guide/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src="https://images.unsplash.com/photo-1518186285589-2f7649de83e0?w=800&amp;h=400&amp;fit=crop" alt=搜索算法与图论></figure><header class=entry-header><h2 class=entry-hint-parent>搜索算法详解：BFS与DFS的原理和应用</h2></header><div class=entry-content><p>搜索算法概述 搜索算法是计算机科学中的基础算法，用于在数据结构中查找特定元素或路径。在图论和树结构中，最重要的两种搜索算法是广度优先搜索（BFS）和深度优先搜索（DFS）。
广度优先搜索（BFS） BFS基本原理 **广度优先搜索（Breadth-First Search）**是一种图遍历算法，它从起始节点开始，逐层向外扩展，先访问距离起始节点最近的所有节点，再访问距离更远的节点。
BFS核心特点 特点 描述 应用场景 层次遍历 按距离起始点的层次逐层访问 最短路径问题 队列实现 使用队列（FIFO）存储待访问节点 保证访问顺序 完备性 如果解存在，一定能找到 状态空间搜索 最优性 在无权图中能找到最短路径 最短路径算法 BFS算法实现 1. 基础BFS模板 from collections import deque def bfs_template(graph, start): """ BFS算法通用模板 Args: graph: 图的邻接表表示 {node: [neighbors]} start: 起始节点 Returns: visited: 访问过的节点集合 """ visited = set() queue = deque([start]) visited.add(start) while queue: current = queue.popleft() print(f"访问节点: {current}") # 遍历当前节点的所有邻居 for neighbor in graph.get(current, []): if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return visited # 示例图 graph = { 'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E'] } visited_nodes = bfs_template(graph, 'A') print("BFS访问的节点:", visited_nodes) 2. BFS求最短路径 def bfs_shortest_path(graph, start, target): """ 使用BFS求无权图中的最短路径 Args: graph: 图的邻接表 start: 起始节点 target: 目标节点 Returns: (distance, path): 最短距离和路径 """ if start == target: return 0, [start] visited = set([start]) queue = deque([(start, 0, [start])]) # (节点, 距离, 路径) while queue: current, distance, path = queue.popleft() for neighbor in graph.get(current, []): if neighbor == target: return distance + 1, path + [neighbor] if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, distance + 1, path + [neighbor])) return -1, [] # 无法到达 # 示例使用 distance, path = bfs_shortest_path(graph, 'A', 'F') print(f"从A到F的最短距离: {distance}") print(f"最短路径: {' -> '.join(path)}") 3. BFS层次遍历 def bfs_level_order(graph, start): """ BFS层次遍历，返回每一层的节点 Args: graph: 图的邻接表 start: 起始节点 Returns: levels: 每一层的节点列表 """ visited = set([start]) current_level = [start] levels = [] while current_level: levels.append(current_level[:]) # 复制当前层 next_level = [] for node in current_level: for neighbor in graph.get(node, []): if neighbor not in visited: visited.add(neighbor) next_level.append(neighbor) current_level = next_level return levels # 示例使用 levels = bfs_level_order(graph, 'A') for i, level in enumerate(levels): print(f"第{i}层: {level}") BFS在二叉树中的应用 class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bfs_tree_traversal(root): """ 二叉树的BFS遍历（层序遍历） Args: root: 二叉树根节点 Returns: result: 层序遍历结果 """ if not root: return [] result = [] queue = deque([root]) while queue: node = queue.popleft() result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result def bfs_tree_level_order(root): """ 二叉树的分层遍历 Args: root: 二叉树根节点 Returns: levels: 每一层的节点值列表 """ if not root: return [] levels = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) levels.append(current_level) return levels # 构建示例二叉树 # 3 # / \ # 9 20 # / \ # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) print("BFS遍历:", bfs_tree_traversal(root)) print("分层遍历:", bfs_tree_level_order(root)) 深度优先搜索（DFS） DFS基本原理 **深度优先搜索（Depth-First Search）**是一种图遍历算法，它从起始节点开始，沿着一条路径尽可能深入，直到无法继续为止，然后回溯到上一个节点，继续探索其他路径。
...</p></div><footer class=entry-footer><span title='2024-02-27 22:05:13 +0800 CST'>February 27, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;tyhzxh</footer><a class=entry-link aria-label="post link to 搜索算法详解：BFS与DFS的原理和应用" href=https://tyhzxh.github.io/posts/search-algorithms-guide/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src="https://images.unsplash.com/photo-1635070041078-e363dbe005cb?w=800&amp;h=400&amp;fit=crop" alt=汉诺塔问题示意图></figure><header class=entry-header><h2 class=entry-hint-parent>递归与分治算法详解</h2></header><div class=entry-content><p>递归算法概述 递归是一种重要的算法设计思想，它将复杂问题分解为规模更小的同类子问题来解决。递归算法的核心在于找到问题的递归关系和边界条件。
经典汉诺塔问题 汉诺塔是学习递归算法的经典问题。这个问题看似简单，但蕴含着深刻的递归思想。
问题描述 有三根柱子A、B、C，n个圆盘从下面开始按大小顺序摆放在A柱子上。规则如下：
任何时候，小圆盘上都不能放大圆盘 三根柱子之间一次只能移动一个圆盘 求将所有圆盘从A柱移动到C柱的最少移动步骤 递归解法 核心思想 要将n个盘子从A移动到C，可以分解为三个步骤：
将上面的n-1个盘子从A移动到B（以C为辅助） 将最大的盘子从A移动到C 将n-1个盘子从B移动到C（以A为辅助） 递归公式 Hanoi(A, C, B, n) = Hanoi(A, B, C, n-1) + move(A, C, n) + Hanoi(B, C, A, n-1) 其中：
Hanoi(A, C, B, n) 表示将n个盘子从A柱移动到C柱，B柱作为辅助 move(A, C, n) 表示将编号为n的盘子从A移动到C 代码实现 #include &lt;iostream> using namespace std; void move(char from, char to, int disk) { cout &lt;&lt; "移动盘子 " &lt;&lt; disk &lt;&lt; ": " &lt;&lt; from &lt;&lt; " --> " &lt;&lt; to &lt;&lt; endl; } void hanoi(char from, char to, char aux, int n) { if (n == 1) { // 边界条件：只有一个盘子时，直接移动 move(from, to, n); } else { // 递归步骤1：将上面n-1个盘子移动到辅助柱 hanoi(from, aux, to, n - 1); // 递归步骤2：移动最大的盘子 move(from, to, n); // 递归步骤3：将n-1个盘子从辅助柱移动到目标柱 hanoi(aux, to, from, n - 1); } } int main() { int n; cout &lt;&lt; "请输入盘子数量: "; cin >> n; cout &lt;&lt; "汉诺塔移动步骤：" &lt;&lt; endl; hanoi('A', 'C', 'B', n); return 0; } Python版本实现 def move(from_pole, to_pole, disk): """移动单个盘子""" print(f"移动盘子 {disk}: {from_pole} --> {to_pole}") def hanoi(from_pole, to_pole, aux_pole, n): """ 汉诺塔递归解法 from_pole: 起始柱 to_pole: 目标柱 aux_pole: 辅助柱 n: 盘子数量 """ if n == 1: # 边界条件：只有一个盘子时，直接移动 move(from_pole, to_pole, n) else: # 步骤1：将上面n-1个盘子移动到辅助柱 hanoi(from_pole, aux_pole, to_pole, n - 1) # 步骤2：移动最大的盘子到目标柱 move(from_pole, to_pole, n) # 步骤3：将n-1个盘子从辅助柱移动到目标柱 hanoi(aux_pole, to_pole, from_pole, n - 1) def count_moves(n): """计算移动次数""" return 2**n - 1 # 示例使用 if __name__ == "__main__": n = int(input("请输入盘子数量: ")) print(f"\n{n}个盘子的汉诺塔移动步骤：") hanoi('A', 'C', 'B', n) print(f"\n总移动次数: {count_moves(n)}") 递归的本质理解 1. 递归是一种树形结构 递归算法的执行过程可以看作是一棵树：
...</p></div><footer class=entry-footer><span title='2024-02-27 22:03:04 +0800 CST'>February 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;tyhzxh</footer><a class=entry-link aria-label="post link to 递归与分治算法详解" href=https://tyhzxh.github.io/posts/recursion-and-divide-conquer/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src="https://images.unsplash.com/photo-1509228468518-180dd4864904?w=800&amp;h=400&amp;fit=crop" alt=算法思维与优化></figure><header class=entry-header><h2 class=entry-hint-parent>贪心算法详解：从基础概念到经典问题</h2></header><div class=entry-content><p>贪心算法概述 **贪心算法（Greedy Algorithm）**是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。贪心算法在算法竞赛和实际工程中都有着重要的地位。
贪心算法的核心思想 基本原理 贪心算法的核心思想是：
局部最优选择：在每一步都做出当前看起来最优的选择 不回溯：一旦做出选择，就不再改变 希望全局最优：通过局部最优选择达到全局最优解 贪心选择性质 一个问题能够用贪心算法解决，必须具备以下性质：
性质 描述 重要性 贪心选择性质 通过局部最优选择能达到全局最优 核心性质 最优子结构 问题的最优解包含子问题的最优解 必要条件 无后效性 当前选择不影响之前的选择 保证正确性 贪心算法设计步骤 1. 问题分析 def greedy_algorithm_template(problem_input): """ 贪心算法通用模板 """ # 步骤1：将问题分解为子问题 subproblems = decompose_problem(problem_input) # 步骤2：确定贪心策略 strategy = define_greedy_strategy() # 步骤3：按贪心策略排序 sorted_items = sort_by_strategy(subproblems, strategy) # 步骤4：逐步构造解 solution = [] for item in sorted_items: if is_feasible(solution, item): solution.append(item) return solution 2. 贪心策略选择 常见的贪心策略包括：
策略类型 描述 适用场景 最大优先 优先选择最大值 最大收益问题 最小优先 优先选择最小值 最小成本问题 比值优先 按某种比值排序 效率优化问题 截止时间优先 按时间排序 调度问题 经典贪心算法问题 1. 活动选择问题 问题描述 给定n个活动，每个活动都有开始时间和结束时间，选择最多的活动使得它们不冲突。
...</p></div><footer class=entry-footer><span title='2024-02-27 22:02:23 +0800 CST'>February 27, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;tyhzxh</footer><a class=entry-link aria-label="post link to 贪心算法详解：从基础概念到经典问题" href=https://tyhzxh.github.io/posts/greedy-algorithm-guide/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src="https://images.unsplash.com/photo-1509228468518-180dd4864904?w=800&amp;h=400&amp;fit=crop" alt=前缀和算法示意图></figure><header class=entry-header><h2 class=entry-hint-parent>前缀和算法详解与应用</h2></header><div class=entry-content><p>前缀和算法概述 前缀和是一种重要的算法技巧，主要用于快速计算数组区间内的各种统计信息。通过预处理构建前缀数组，可以将原本需要O(n)时间复杂度的区间查询优化到O(1)。
前缀和算法的核心思想是：利用前面已经计算过的结果来快速得出当前的结果。
前缀和的基本类型 1. 累计值前缀数组（用于区间求和） 这是最常见的前缀和应用，用于快速计算数组中任意区间的元素和。
def build_prefix_sum(arr): """构建前缀和数组""" prefix_sum = [0] # 初始化前缀和数组，第一个元素为0 for num in arr: prefix_sum.append(prefix_sum[-1] + num) # 将当前元素加到前一个前缀和上 return prefix_sum def range_sum(prefix_sum, start, end): """计算区间和""" return prefix_sum[end + 1] - prefix_sum[start] # 示例使用 arr = [1, 2, 3, 4, 5] prefix_sum = build_prefix_sum(arr) print(f"原数组: {arr}") print(f"前缀和数组: {prefix_sum}") # 查询区间 [1, 3] 的和 (索引1到3，即元素2, 3, 4) result = range_sum(prefix_sum, 1, 3) print(f"区间 [1, 3] 的和: {result}") # 输出 9 (2 + 3 + 4) 算法解释：
build_prefix_sum 函数通过遍历输入数组并累加每个元素来构建前缀和数组 前缀和数组的第一个元素初始化为0，表示空区间的和 range_sum 函数利用前缀和的性质：区间[start, end]的和 = prefix_sum[end+1] - prefix_sum[start] 2. 累计出现次数前缀数组 用于快速查询某个特定值在指定区间内的出现次数。
def build_prefix_count(arr, target): """构建目标值的前缀计数数组""" prefix_count = [0] # 初始化前缀计数数组 for num in arr: if num == target: prefix_count.append(prefix_count[-1] + 1) # 如果是目标值，计数加1 else: prefix_count.append(prefix_count[-1]) # 否则，计数不变 return prefix_count def count_range_occurrences(prefix_count, start, end): """计算区间内目标值的出现次数""" return prefix_count[end + 1] - prefix_count[start] # 示例使用 arr = [1, 3, 2, 3, 3, 4] target = 3 prefix_count = build_prefix_count(arr, target) print(f"原数组: {arr}") print(f"目标值 {target} 的前缀计数数组: {prefix_count}") # 查询区间 [1, 4] 中目标值的出现次数 result = count_range_occurrences(prefix_count, 1, 4) print(f"区间 [1, 4] 中值 {target} 的出现次数: {result}") # 输出 3 算法解释：
...</p></div><footer class=entry-footer><span title='2024-02-23 13:34:50 +0800 CST'>February 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;tyhzxh</footer><a class=entry-link aria-label="post link to 前缀和算法详解与应用" href=https://tyhzxh.github.io/posts/prefix-sum-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SpringBoot 核心概念详解</h2></header><div class=entry-content><p>SpringBoot是Java最流行的开发框架，它通过解耦代码来提升可维护性和可测试性。本文将深入解析SpringBoot的核心概念。
框架概述 SpringBoot 是基于Spring框架的快速开发脚手架，它简化了Spring应用的配置和部署过程，让开发者能够快速构建生产级别的应用程序。
主要优势 🚀 快速启动：提供开箱即用的配置 🔧 自动配置：根据依赖自动配置应用 📦 内嵌服务器：无需外部容器即可运行 🎯 简化配置：约定优于配置的理念 Spring 核心概念 Spring框架有三个最关键的核心概念：IoC容器、依赖注入(DI)、面向切面编程(AOP)。
一、IoC容器（控制反转） 什么是IoC？ IoC (Inversion of Control) 控制反转，是一种设计原则。传统的程序设计中，对象的创建和依赖关系由程序代码直接控制，而IoC将这种控制权交给了框架。
传统方式 vs IoC方式 传统方式：
public class UserService { private UserDao userDao = new UserDao(); // 手动创建依赖 public void saveUser(User user) { userDao.save(user); } } IoC方式：
@Service public class UserService { @Autowired private UserDao userDao; // 框架自动注入 public void saveUser(User user) { userDao.save(user); } } IoC的优势 降低耦合度：对象之间的依赖关系由框架管理 提高可测试性：便于进行单元测试和Mock 增强可维护性：修改依赖关系无需修改业务代码 支持配置化：可以通过配置文件管理对象关系 二、依赖注入（DI） 什么是依赖注入？ DI (Dependency Injection) 依赖注入，是IoC容器的具体实现方式。它是一种设计模式，用于实现对象之间的松耦合。
...</p></div><footer class=entry-footer><span title='2024-02-23 02:36:48 +0800 CST'>February 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;tyhzxh</footer><a class=entry-link aria-label="post link to SpringBoot 核心概念详解" href=https://tyhzxh.github.io/posts/springboot-fundamentals/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git 版本控制学习笔记</h2></header><div class=entry-content><p>本文是学习廖雪峰Git教程的学习笔记，整理了Git的基础概念和常用操作。
基础概念 在.git文件所在目录下进行操作
Git有三个重要的区域：
工作区(Working Directory) - 所处的文件目录 暂存区(Stage) - 重点概念，临时存储修改的地方 版本库(Repository) - 工作区有一个隐藏目录 .git，这个不算工作区，而是Git的版本库 重要提示：创建Git版本库时，Git自动为我们创建了唯一一个master(main)分支，所以git commit就是往master(main)分支上提交更改。
基础操作(Windows下) 核心理念：git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。
推荐环境：在PowerShell或Git Bash下输入命令 建议使用Git Bash - 支持很多Linux下的命令
初始化和添加文件 初始化Git仓库：使用git init命令 添加文件到Git仓库，分两步： 使用命令git add &lt;file>，注意，可反复多次使用，添加多个工作区文件到暂存区 使用命令git commit -m &lt;message>添加暂存区所有文件到Git仓库，完成 💡 实用技巧 # 一次性添加所有改动 git add . 检查操作 查看状态 检查 工作区+暂存区 的状态，使用git status命令：
Changes to be committed: (use "git restore --staged &lt;file>..." to unstage) modified: 1.md Changes not staged for commit: (use "git add &lt;file>..." to update what will be committed) (use "git restore &lt;file>..." to discard changes in working directory) modified: 1.md 查看修改内容 如果git status告诉你有文件被修改过，用git diff可以查看修改内容：
...</p></div><footer class=entry-footer><span title='2024-02-09 17:44:43 +0800 CST'>February 9, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;tyhzxh</footer><a class=entry-link aria-label="post link to Git 版本控制学习笔记" href=https://tyhzxh.github.io/posts/git-notes/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://tyhzxh.github.io/images/git-workflow.svg alt=Git工作流程图></figure><header class=entry-header><h2 class=entry-hint-parent>Git版本控制基础指南</h2></header><div class=entry-content><p>前言 本文是学习廖雪峰Git教程的学习笔记，涵盖了Git版本控制系统的基础概念和常用操作。Git是目前最流行的分布式版本控制系统，掌握Git对于软件开发至关重要。
注意：所有Git操作都需要在.git文件所在目录下进行
基础概念 Git的三个区域 Git将文件管理分为三个主要区域：
工作区（Working Directory）
就是你在电脑里能看到的目录 存放项目文件的地方 暂存区（Stage/Index） ⭐ 重点
临时存放文件修改的地方 位于.git目录中的index文件 版本库（Repository）
工作区有一个隐藏目录.git，这就是Git的版本库 包含暂存区和分支信息 Git自动创建的第一个分支是master（或main） 工作流程 graph LR A[工作区] -->|git add| B[暂存区] B -->|git commit| C[版本库] C -->|git checkout| A 核心理念：
git add命令把要提交的所有修改放到暂存区 git commit一次性把暂存区的所有修改提交到分支 基础操作 环境准备 推荐使用Git Bash，因为它支持很多Linux命令，在Windows下提供更好的体验。
仓库初始化 # 初始化Git仓库 git init 文件添加和提交 # 添加单个文件到暂存区 git add &lt;file> # 添加所有修改到暂存区 ⭐ 常用 git add . # 提交暂存区的所有文件到版本库 git commit -m "提交说明" 完整流程示例：
...</p></div><footer class=entry-footer><span title='2024-02-09 17:44:43 +0800 CST'>February 9, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;tyhzxh</footer><a class=entry-link aria-label="post link to Git版本控制基础指南" href=https://tyhzxh.github.io/posts/git-fundamentals-guide/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://tyhzxh.github.io/posts/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://tyhzxh.github.io/posts/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://tyhzxh.github.io/>tyhzxh的个人博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>