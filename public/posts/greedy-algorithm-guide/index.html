<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>贪心算法详解：从基础概念到经典问题 | tyhzxh的个人博客</title><meta name=keywords content="算法,贪心算法,算法设计,优化问题,数据结构"><meta name=description content="深入解析贪心算法的核心思想、设计原则和应用场景，通过经典问题实例掌握贪心策略的选择和证明方法，包括活动选择、背包问题、最短路径等"><meta name=author content="tyhzxh"><link rel=canonical href=https://tyhzxh.github.io/posts/greedy-algorithm-guide/><link crossorigin=anonymous href=/assets/css/stylesheet.8ee78296343cf29844826f6d943ca1b6638fc5059dcdf673ace996a7617f1b69.css integrity="sha256-jueCljQ88phEgm9tlDyhtmOPxQWdzfZzrOmWp2F/G2k=" rel="preload stylesheet" as=style><link rel=icon href=https://tyhzxh.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tyhzxh.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tyhzxh.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tyhzxh.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tyhzxh.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tyhzxh.github.io/posts/greedy-algorithm-guide/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>.archive-summary{margin-bottom:2rem;padding:1rem;background:var(--theme);border-radius:8px;border:1px solid var(--border);text-align:center;color:var(--secondary);font-size:.9rem}.pagination{display:flex;justify-content:center;align-items:center;gap:1rem;margin:3rem 0;padding:2rem 0;border-top:1px solid var(--border)}.pagination-prev,.pagination-next{padding:.75rem 1.5rem;background:var(--entry);border:1px solid var(--border);border-radius:6px;text-decoration:none;color:var(--primary);font-weight:500;transition:all .3s ease;box-shadow:0 2px 4px rgba(0,0,0,5%)}.pagination-prev:hover,.pagination-next:hover{background:var(--hljs-bg);color:var(--primary);transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,.1);border-color:var(--tertiary)}.pagination-numbers{display:flex;gap:.5rem;align-items:center}.pagination-number,.pagination-current{display:inline-flex;align-items:center;justify-content:center;width:2.5rem;height:2.5rem;border-radius:50%;text-decoration:none;font-weight:500;transition:all .3s ease}.pagination-number{background:var(--entry);border:1px solid var(--border);color:var(--primary);box-shadow:0 2px 4px rgba(0,0,0,5%)}.pagination-number:hover{background:var(--hljs-bg);color:var(--primary);transform:scale(1.1);border-color:var(--tertiary)}.pagination-current{background:var(--tertiary);color:var(--primary);border:1px solid var(--tertiary);font-weight:600;box-shadow:0 2px 4px rgba(0,0,0,.1)}@media(max-width:768px){.pagination{flex-direction:column;gap:1rem}.pagination-prev,.pagination-next{width:100%;text-align:center}.pagination-numbers{order:-1}.archive-summary{font-size:.8rem;padding:.75rem}}[data-theme=dark] .archive-summary{background:var(--entry)}[data-theme=dark] .pagination-prev,[data-theme=dark] .pagination-next,[data-theme=dark] .pagination-number{background:var(--entry);border-color:var(--border);box-shadow:0 2px 4px rgba(0,0,0,.2)}[data-theme=dark] .pagination-prev:hover,[data-theme=dark] .pagination-next:hover,[data-theme=dark] .pagination-number:hover{background:var(--hljs-bg);border-color:var(--tertiary)}[data-theme=dark] .pagination-current{background:var(--tertiary);border-color:var(--tertiary);box-shadow:0 2px 4px rgba(0,0,0,.3)}</style><meta property="og:url" content="https://tyhzxh.github.io/posts/greedy-algorithm-guide/"><meta property="og:site_name" content="tyhzxh的个人博客"><meta property="og:title" content="贪心算法详解：从基础概念到经典问题"><meta property="og:description" content="深入解析贪心算法的核心思想、设计原则和应用场景，通过经典问题实例掌握贪心策略的选择和证明方法，包括活动选择、背包问题、最短路径等"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-27T22:02:23+08:00"><meta property="article:modified_time" content="2025-08-06T08:51:21+08:00"><meta property="article:tag" content="算法"><meta property="article:tag" content="贪心算法"><meta property="article:tag" content="算法设计"><meta property="article:tag" content="优化问题"><meta property="article:tag" content="数据结构"><meta property="og:image" content="https://images.unsplash.com/photo-1509228468518-180dd4864904?w=800&amp;h=400&amp;fit=crop"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1509228468518-180dd4864904?w=800&amp;h=400&amp;fit=crop"><meta name=twitter:title content="贪心算法详解：从基础概念到经典问题"><meta name=twitter:description content="深入解析贪心算法的核心思想、设计原则和应用场景，通过经典问题实例掌握贪心策略的选择和证明方法，包括活动选择、背包问题、最短路径等"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tyhzxh.github.io/posts/"},{"@type":"ListItem","position":2,"name":"贪心算法详解：从基础概念到经典问题","item":"https://tyhzxh.github.io/posts/greedy-algorithm-guide/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"贪心算法详解：从基础概念到经典问题","name":"贪心算法详解：从基础概念到经典问题","description":"深入解析贪心算法的核心思想、设计原则和应用场景，通过经典问题实例掌握贪心策略的选择和证明方法，包括活动选择、背包问题、最短路径等","keywords":["算法","贪心算法","算法设计","优化问题","数据结构"],"articleBody":"贪心算法概述 **贪心算法（Greedy Algorithm）**是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。贪心算法在算法竞赛和实际工程中都有着重要的地位。\n贪心算法的核心思想 基本原理 贪心算法的核心思想是：\n局部最优选择：在每一步都做出当前看起来最优的选择 不回溯：一旦做出选择，就不再改变 希望全局最优：通过局部最优选择达到全局最优解 贪心选择性质 一个问题能够用贪心算法解决，必须具备以下性质：\n性质 描述 重要性 贪心选择性质 通过局部最优选择能达到全局最优 核心性质 最优子结构 问题的最优解包含子问题的最优解 必要条件 无后效性 当前选择不影响之前的选择 保证正确性 贪心算法设计步骤 1. 问题分析 def greedy_algorithm_template(problem_input): \"\"\" 贪心算法通用模板 \"\"\" # 步骤1：将问题分解为子问题 subproblems = decompose_problem(problem_input) # 步骤2：确定贪心策略 strategy = define_greedy_strategy() # 步骤3：按贪心策略排序 sorted_items = sort_by_strategy(subproblems, strategy) # 步骤4：逐步构造解 solution = [] for item in sorted_items: if is_feasible(solution, item): solution.append(item) return solution 2. 贪心策略选择 常见的贪心策略包括：\n策略类型 描述 适用场景 最大优先 优先选择最大值 最大收益问题 最小优先 优先选择最小值 最小成本问题 比值优先 按某种比值排序 效率优化问题 截止时间优先 按时间排序 调度问题 经典贪心算法问题 1. 活动选择问题 问题描述 给定n个活动，每个活动都有开始时间和结束时间，选择最多的活动使得它们不冲突。\n贪心策略 按结束时间排序，优先选择结束时间最早的活动\ndef activity_selection(activities): \"\"\" 活动选择问题 - 贪心算法 Args: activities: [(start_time, end_time, activity_id), ...] Returns: selected_activities: 选中的活动列表 \"\"\" # 按结束时间排序 activities.sort(key=lambda x: x[1]) selected = [] last_end_time = 0 for start, end, activity_id in activities: # 如果当前活动的开始时间 \u003e= 上一个活动的结束时间 if start \u003e= last_end_time: selected.append((start, end, activity_id)) last_end_time = end return selected # 示例使用 activities = [ (1, 4, 'A'), # 活动A: 1-4 (3, 5, 'B'), # 活动B: 3-5 (0, 6, 'C'), # 活动C: 0-6 (5, 7, 'D'), # 活动D: 5-7 (3, 9, 'E'), # 活动E: 3-9 (5, 9, 'F'), # 活动F: 5-9 (6, 10, 'G'), # 活动G: 6-10 (8, 11, 'H'), # 活动H: 8-11 (8, 12, 'I'), # 活动I: 8-12 (2, 14, 'J'), # 活动J: 2-14 (12, 16, 'K') # 活动K: 12-16 ] result = activity_selection(activities) print(\"选中的活动:\", result) # 输出: [(1, 4, 'A'), (5, 7, 'D'), (8, 11, 'H'), (12, 16, 'K')] 正确性证明 def prove_activity_selection(): \"\"\" 活动选择问题正确性证明思路： 1. 贪心选择性质： - 设最优解为OPT，贪心解为GREEDY - 如果OPT的第一个活动不是最早结束的， 可以替换为最早结束的活动，不会使解变差 2. 最优子结构： - 选择第一个活动后，剩余问题仍是活动选择问题 - 原问题的最优解 = 第一个活动 + 子问题的最优解 \"\"\" pass 2. 分数背包问题 问题描述 有一个容量为W的背包和n个物品，每个物品有重量和价值，可以取物品的一部分，求最大价值。\ndef fractional_knapsack(items, capacity): \"\"\" 分数背包问题 - 贪心算法 Args: items: [(weight, value, item_id), ...] capacity: 背包容量 Returns: (max_value, selected_items): 最大价值和选中的物品 \"\"\" # 按价值密度（价值/重量）降序排序 items.sort(key=lambda x: x[1]/x[0], reverse=True) total_value = 0 selected_items = [] remaining_capacity = capacity for weight, value, item_id in items: if remaining_capacity \u003e= weight: # 完全装入 selected_items.append((weight, value, item_id, 1.0)) total_value += value remaining_capacity -= weight elif remaining_capacity \u003e 0: # 部分装入 fraction = remaining_capacity / weight selected_items.append((weight, value, item_id, fraction)) total_value += value * fraction remaining_capacity = 0 break return total_value, selected_items # 示例使用 items = [ (10, 60, 'A'), # 物品A: 重量10, 价值60, 密度6.0 (20, 100, 'B'), # 物品B: 重量20, 价值100, 密度5.0 (30, 120, 'C') # 物品C: 重量30, 价值120, 密度4.0 ] max_value, selected = fractional_knapsack(items, 50) print(f\"最大价值: {max_value}\") print(\"选中的物品:\", selected) # 输出: 最大价值: 240.0 # 选中的物品: [(10, 60, 'A', 1.0), (20, 100, 'B', 1.0), (30, 120, 'C', 0.6667)] 3. 哈夫曼编码 问题描述 给定字符频率，构造最优前缀编码，使得编码总长度最小。\nimport heapq from collections import defaultdict, Counter class HuffmanNode: def __init__(self, char=None, freq=0, left=None, right=None): self.char = char self.freq = freq self.left = left self.right = right def __lt__(self, other): return self.freq \u003c other.freq def huffman_encoding(text): \"\"\" 哈夫曼编码 - 贪心算法 Args: text: 输入文本 Returns: (encoded_text, huffman_tree, codes): 编码结果、哈夫曼树、编码表 \"\"\" # 统计字符频率 freq_map = Counter(text) # 创建优先队列（最小堆） heap = [] for char, freq in freq_map.items(): heapq.heappush(heap, HuffmanNode(char, freq)) # 构建哈夫曼树 while len(heap) \u003e 1: # 取出频率最小的两个节点 left = heapq.heappop(heap) right = heapq.heappop(heap) # 创建新的内部节点 merged = HuffmanNode( freq=left.freq + right.freq, left=left, right=right ) heapq.heappush(heap, merged) # 根节点 root = heap[0] if heap else None # 生成编码表 codes = {} def generate_codes(node, code=\"\"): if node: if node.char: # 叶子节点 codes[node.char] = code if code else \"0\" else: # 内部节点 generate_codes(node.left, code + \"0\") generate_codes(node.right, code + \"1\") generate_codes(root) # 编码文本 encoded_text = \"\".join(codes[char] for char in text) return encoded_text, root, codes # 示例使用 text = \"ABRACADABRA\" encoded, tree, codes = huffman_encoding(text) print(\"原文本:\", text) print(\"字符编码:\", codes) print(\"编码结果:\", encoded) print(f\"压缩率: {len(encoded)} / {len(text) * 8} = {len(encoded) / (len(text) * 8):.2%}\") # 解码函数 def huffman_decoding(encoded_text, root): \"\"\"哈夫曼解码\"\"\" if not root: return \"\" decoded = [] current = root for bit in encoded_text: if bit == '0': current = current.left else: current = current.right if current.char: # 到达叶子节点 decoded.append(current.char) current = root return \"\".join(decoded) decoded = huffman_decoding(encoded, tree) print(\"解码结果:\", decoded) 4. 最小生成树（Kruskal算法） class UnionFind: \"\"\"并查集数据结构\"\"\" def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): px, py = self.find(x), self.find(y) if px == py: return False if self.rank[px] \u003c self.rank[py]: px, py = py, px self.parent[py] = px if self.rank[px] == self.rank[py]: self.rank[px] += 1 return True def kruskal_mst(n, edges): \"\"\" Kruskal最小生成树算法 - 贪心算法 Args: n: 顶点数量 edges: [(weight, u, v), ...] 边的列表 Returns: (mst_weight, mst_edges): 最小生成树的权重和边 \"\"\" # 按权重排序 edges.sort() uf = UnionFind(n) mst_edges = [] mst_weight = 0 for weight, u, v in edges: if uf.union(u, v): # 如果不形成环 mst_edges.append((weight, u, v)) mst_weight += weight if len(mst_edges) == n - 1: # 生成树完成 break return mst_weight, mst_edges # 示例使用 edges = [ (1, 0, 1), # 边 0-1，权重1 (2, 0, 2), # 边 0-2，权重2 (3, 1, 2), # 边 1-2，权重3 (4, 1, 3), # 边 1-3，权重4 (5, 2, 3), # 边 2-3，权重5 ] weight, mst = kruskal_mst(4, edges) print(f\"最小生成树权重: {weight}\") print(\"最小生成树边:\", mst) 5. 区间调度问题 def interval_scheduling(intervals): \"\"\" 区间调度问题 - 贪心算法 选择最多的不重叠区间 Args: intervals: [(start, end, interval_id), ...] Returns: selected_intervals: 选中的区间列表 \"\"\" # 按结束时间排序 intervals.sort(key=lambda x: x[1]) selected = [] last_end = float('-inf') for start, end, interval_id in intervals: if start \u003e= last_end: # 不重叠 selected.append((start, end, interval_id)) last_end = end return selected def interval_coloring(intervals): \"\"\" 区间着色问题 - 贪心算法 用最少的颜色给所有区间着色，使得重叠区间颜色不同 Args: intervals: [(start, end, interval_id), ...] Returns: coloring: {interval_id: color} \"\"\" # 按开始时间排序 intervals.sort(key=lambda x: x[0]) coloring = {} color_end_times = [] # 每种颜色的最后结束时间 for start, end, interval_id in intervals: # 找到可以复用的颜色 color = -1 for i, end_time in enumerate(color_end_times): if start \u003e= end_time: color = i break if color == -1: # 需要新颜色 color = len(color_end_times) color_end_times.append(end) else: # 复用颜色 color_end_times[color] = end coloring[interval_id] = color return coloring, len(color_end_times) # 示例使用 intervals = [ (1, 3, 'A'), (2, 4, 'B'), (3, 5, 'C'), (4, 6, 'D') ] # 区间调度 selected = interval_scheduling(intervals) print(\"选中的区间:\", selected) # 区间着色 coloring, num_colors = interval_coloring(intervals) print(\"着色方案:\", coloring) print(\"需要颜色数:\", num_colors) 贪心算法的应用场景 1. 调度问题 def job_scheduling_with_deadlines(jobs): \"\"\" 带截止时间的作业调度 - 贪心算法 Args: jobs: [(profit, deadline, job_id), ...] Returns: (max_profit, scheduled_jobs): 最大利润和调度的作业 \"\"\" # 按利润降序排序 jobs.sort(key=lambda x: x[0], reverse=True) # 找到最大截止时间 max_deadline = max(job[1] for job in jobs) # 时间槽数组，-1表示空闲 time_slots = [-1] * max_deadline scheduled_jobs = [] total_profit = 0 for profit, deadline, job_id in jobs: # 从截止时间往前找空闲时间槽 for t in range(min(deadline - 1, max_deadline - 1), -1, -1): if time_slots[t] == -1: time_slots[t] = job_id scheduled_jobs.append((profit, deadline, job_id)) total_profit += profit break return total_profit, scheduled_jobs # 示例使用 jobs = [ (100, 2, 'J1'), # 作业J1: 利润100, 截止时间2 (10, 1, 'J2'), # 作业J2: 利润10, 截止时间1 (15, 2, 'J3'), # 作业J3: 利润15, 截止时间2 (27, 1, 'J4'), # 作业J4: 利润27, 截止时间1 ] profit, scheduled = job_scheduling_with_deadlines(jobs) print(f\"最大利润: {profit}\") print(\"调度的作业:\", scheduled) 2. 图论问题 def dijkstra_shortest_path(graph, start): \"\"\" Dijkstra最短路径算法 - 贪心算法 Args: graph: {node: [(neighbor, weight), ...]} start: 起始节点 Returns: distances: {node: shortest_distance} \"\"\" import heapq distances = {node: float('inf') for node in graph} distances[start] = 0 # 优先队列：(distance, node) pq = [(0, start)] visited = set() while pq: current_dist, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) # 更新邻居节点的距离 for neighbor, weight in graph.get(current_node, []): if neighbor not in visited: new_dist = current_dist + weight if new_dist \u003c distances[neighbor]: distances[neighbor] = new_dist heapq.heappush(pq, (new_dist, neighbor)) return distances # 示例使用 graph = { 'A': [('B', 4), ('C', 2)], 'B': [('C', 1), ('D', 5)], 'C': [('D', 8), ('E', 10)], 'D': [('E', 2)], 'E': [] } distances = dijkstra_shortest_path(graph, 'A') print(\"从A到各点的最短距离:\", distances) 贪心算法的局限性 1. 不适用的问题 def knapsack_01_counterexample(): \"\"\" 0-1背包问题：贪心算法不能得到最优解 \"\"\" # 物品: (重量, 价值) items = [(10, 60), (20, 100), (30, 120)] capacity = 50 # 贪心策略：按价值密度排序 # 密度: [6.0, 5.0, 4.0] # 贪心选择: 物品1(10,60) + 物品2(20,100) = 价值160 # 最优解: 物品2(20,100) + 物品3(30,120) = 价值220 print(\"贪心算法不适用于0-1背包问题\") print(\"贪心解: 160, 最优解: 220\") def coin_change_counterexample(): \"\"\" 硬币找零问题：某些币值系统下贪心算法不能得到最优解 \"\"\" # 币值系统: [1, 3, 4] # 目标金额: 6 # 贪心策略：优先使用大面额 # 贪心解: 4 + 1 + 1 = 3枚硬币 # 最优解: 3 + 3 = 2枚硬币 print(\"某些币值系统下，贪心算法不能得到最优解\") print(\"贪心解: 3枚硬币, 最优解: 2枚硬币\") 2. 贪心算法的适用条件 条件 说明 检验方法 贪心选择性质 局部最优能导致全局最优 数学证明或反证法 最优子结构 子问题的最优解构成原问题的最优解 递归分析 无后效性 当前选择不影响之前的选择 状态分析 贪心算法设计技巧 1. 策略选择指南 def strategy_selection_guide(): \"\"\" 贪心策略选择指南 \"\"\" strategies = { \"最早截止时间优先\": \"调度问题，避免错过截止时间\", \"最短处理时间优先\": \"最小化平均等待时间\", \"最高价值密度优先\": \"背包类问题，最大化单位收益\", \"最小权重优先\": \"生成树问题，最小化总成本\", \"最大利润优先\": \"选择问题，最大化总收益\" } for strategy, application in strategies.items(): print(f\"{strategy}: {application}\") 2. 正确性证明方法 def greedy_proof_methods(): \"\"\" 贪心算法正确性证明方法 \"\"\" methods = { \"交换论证\": \"证明贪心选择可以替换最优解中的选择\", \"归纳法\": \"证明每一步贪心选择都保持最优性\", \"反证法\": \"假设贪心解不是最优解，推出矛盾\", \"切割粘贴\": \"将最优解分割重组，证明贪心解不差\" } for method, description in methods.items(): print(f\"{method}: {description}\") 实际应用案例 1. 任务调度系统 class TaskScheduler: \"\"\"基于贪心算法的任务调度器\"\"\" def __init__(self): self.tasks = [] def add_task(self, task_id, priority, duration, deadline): \"\"\"添加任务\"\"\" self.tasks.append({ 'id': task_id, 'priority': priority, 'duration': duration, 'deadline': deadline }) def schedule_by_priority(self): \"\"\"按优先级调度\"\"\" return sorted(self.tasks, key=lambda x: x['priority'], reverse=True) def schedule_by_deadline(self): \"\"\"按截止时间调度\"\"\" return sorted(self.tasks, key=lambda x: x['deadline']) def schedule_by_shortest_job_first(self): \"\"\"最短作业优先调度\"\"\" return sorted(self.tasks, key=lambda x: x['duration']) # 示例使用 scheduler = TaskScheduler() scheduler.add_task('T1', 5, 10, 100) scheduler.add_task('T2', 3, 5, 50) scheduler.add_task('T3', 8, 15, 80) print(\"按优先级调度:\", scheduler.schedule_by_priority()) print(\"按截止时间调度:\", scheduler.schedule_by_deadline()) print(\"最短作业优先:\", scheduler.schedule_by_shortest_job_first()) 2. 缓存替换算法 class LRUCache: \"\"\"基于贪心思想的LRU缓存\"\"\" def __init__(self, capacity): self.capacity = capacity self.cache = {} self.access_order = [] def get(self, key): \"\"\"获取缓存值\"\"\" if key in self.cache: # 更新访问顺序（贪心策略：最近使用的放在最后） self.access_order.remove(key) self.access_order.append(key) return self.cache[key] return None def put(self, key, value): \"\"\"设置缓存值\"\"\" if key in self.cache: # 更新现有键 self.cache[key] = value self.access_order.remove(key) self.access_order.append(key) else: # 添加新键 if len(self.cache) \u003e= self.capacity: # 贪心策略：移除最久未使用的键 lru_key = self.access_order.pop(0) del self.cache[lru_key] self.cache[key] = value self.access_order.append(key) # 示例使用 cache = LRUCache(3) cache.put('A', 1) cache.put('B', 2) cache.put('C', 3) print(\"缓存状态:\", cache.cache) cache.get('A') # 访问A cache.put('D', 4) # 添加D，应该移除B print(\"添加D后:\", cache.cache) 学习建议和总结 学习路径 理解核心概念：掌握贪心选择性质和最优子结构 练习经典问题：活动选择、背包问题、最短路径等 学会证明方法：交换论证、归纳法、反证法 识别适用场景：判断问题是否适合贪心算法 实际应用练习：调度、优化、图论等实际问题 关键要点 要点 说明 策略选择 正确的贪心策略是算法成功的关键 正确性证明 必须证明贪心选择能得到最优解 适用性判断 不是所有问题都适合贪心算法 效率优势 贪心算法通常具有较低的时间复杂度 常见误区 盲目应用：不验证贪心选择性质就使用贪心算法 策略错误：选择了错误的贪心策略 忽略证明：没有证明算法的正确性 适用范围：将贪心算法应用到不适合的问题上 贪心算法是算法设计中的重要思想，虽然不能解决所有优化问题，但在适用的场景下能够提供简洁高效的解决方案。掌握贪心算法的关键在于理解其适用条件，选择正确的贪心策略，并能够证明算法的正确性。\n","wordCount":"1546","inLanguage":"en","image":"https://images.unsplash.com/photo-1509228468518-180dd4864904?w=800\u0026h=400\u0026fit=crop","datePublished":"2024-02-27T22:02:23+08:00","dateModified":"2025-08-06T08:51:21+08:00","author":{"@type":"Person","name":"tyhzxh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tyhzxh.github.io/posts/greedy-algorithm-guide/"},"publisher":{"@type":"Organization","name":"tyhzxh的个人博客","logo":{"@type":"ImageObject","url":"https://tyhzxh.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tyhzxh.github.io/ accesskey=h title="tyhzxh的个人博客 (Alt + H)">tyhzxh的个人博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tyhzxh.github.io/ title=首页><span>首页</span></a></li><li><a href=https://tyhzxh.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://tyhzxh.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://tyhzxh.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://tyhzxh.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://tyhzxh.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tyhzxh.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://tyhzxh.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">贪心算法详解：从基础概念到经典问题</h1><div class=post-description>深入解析贪心算法的核心思想、设计原则和应用场景，通过经典问题实例掌握贪心策略的选择和证明方法，包括活动选择、背包问题、最短路径等</div><div class=post-meta><span title='2024-02-27 22:02:23 +0800 CST'>February 27, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;tyhzxh</div></header><figure class=entry-cover><img loading=eager src="https://images.unsplash.com/photo-1509228468518-180dd4864904?w=800&amp;h=400&amp;fit=crop" alt=算法思维与优化></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e6%a6%82%e8%bf%b0 aria-label=贪心算法概述>贪心算法概述</a></li><li><a href=#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e7%9a%84%e6%a0%b8%e5%bf%83%e6%80%9d%e6%83%b3 aria-label=贪心算法的核心思想>贪心算法的核心思想</a><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86 aria-label=基本原理>基本原理</a></li><li><a href=#%e8%b4%aa%e5%bf%83%e9%80%89%e6%8b%a9%e6%80%a7%e8%b4%a8 aria-label=贪心选择性质>贪心选择性质</a></li></ul></li><li><a href=#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e6%ad%a5%e9%aa%a4 aria-label=贪心算法设计步骤>贪心算法设计步骤</a><ul><li><a href=#1-%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90 aria-label="1. 问题分析">1. 问题分析</a></li><li><a href=#2-%e8%b4%aa%e5%bf%83%e7%ad%96%e7%95%a5%e9%80%89%e6%8b%a9 aria-label="2. 贪心策略选择">2. 贪心策略选择</a></li></ul></li><li><a href=#%e7%bb%8f%e5%85%b8%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e9%97%ae%e9%a2%98 aria-label=经典贪心算法问题>经典贪心算法问题</a><ul><li><a href=#1-%e6%b4%bb%e5%8a%a8%e9%80%89%e6%8b%a9%e9%97%ae%e9%a2%98 aria-label="1. 活动选择问题">1. 活动选择问题</a><ul><li><a href=#%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0 aria-label=问题描述>问题描述</a></li><li><a href=#%e8%b4%aa%e5%bf%83%e7%ad%96%e7%95%a5 aria-label=贪心策略>贪心策略</a></li><li><a href=#%e6%ad%a3%e7%a1%ae%e6%80%a7%e8%af%81%e6%98%8e aria-label=正确性证明>正确性证明</a></li></ul></li><li><a href=#2-%e5%88%86%e6%95%b0%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98 aria-label="2. 分数背包问题">2. 分数背包问题</a><ul><li><a href=#%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0-1 aria-label=问题描述>问题描述</a></li></ul></li><li><a href=#3-%e5%93%88%e5%a4%ab%e6%9b%bc%e7%bc%96%e7%a0%81 aria-label="3. 哈夫曼编码">3. 哈夫曼编码</a><ul><li><a href=#%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0-2 aria-label=问题描述>问题描述</a></li></ul></li><li><a href=#4-%e6%9c%80%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91kruskal%e7%ae%97%e6%b3%95 aria-label="4. 最小生成树（Kruskal算法）">4. 最小生成树（Kruskal算法）</a></li><li><a href=#5-%e5%8c%ba%e9%97%b4%e8%b0%83%e5%ba%a6%e9%97%ae%e9%a2%98 aria-label="5. 区间调度问题">5. 区间调度问题</a></li></ul></li><li><a href=#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af aria-label=贪心算法的应用场景>贪心算法的应用场景</a><ul><li><a href=#1-%e8%b0%83%e5%ba%a6%e9%97%ae%e9%a2%98 aria-label="1. 调度问题">1. 调度问题</a></li><li><a href=#2-%e5%9b%be%e8%ae%ba%e9%97%ae%e9%a2%98 aria-label="2. 图论问题">2. 图论问题</a></li></ul></li><li><a href=#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e7%9a%84%e5%b1%80%e9%99%90%e6%80%a7 aria-label=贪心算法的局限性>贪心算法的局限性</a><ul><li><a href=#1-%e4%b8%8d%e9%80%82%e7%94%a8%e7%9a%84%e9%97%ae%e9%a2%98 aria-label="1. 不适用的问题">1. 不适用的问题</a></li><li><a href=#2-%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e7%9a%84%e9%80%82%e7%94%a8%e6%9d%a1%e4%bb%b6 aria-label="2. 贪心算法的适用条件">2. 贪心算法的适用条件</a></li></ul></li><li><a href=#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e6%8a%80%e5%b7%a7 aria-label=贪心算法设计技巧>贪心算法设计技巧</a><ul><li><a href=#1-%e7%ad%96%e7%95%a5%e9%80%89%e6%8b%a9%e6%8c%87%e5%8d%97 aria-label="1. 策略选择指南">1. 策略选择指南</a></li><li><a href=#2-%e6%ad%a3%e7%a1%ae%e6%80%a7%e8%af%81%e6%98%8e%e6%96%b9%e6%b3%95 aria-label="2. 正确性证明方法">2. 正确性证明方法</a></li></ul></li><li><a href=#%e5%ae%9e%e9%99%85%e5%ba%94%e7%94%a8%e6%a1%88%e4%be%8b aria-label=实际应用案例>实际应用案例</a><ul><li><a href=#1-%e4%bb%bb%e5%8a%a1%e8%b0%83%e5%ba%a6%e7%b3%bb%e7%bb%9f aria-label="1. 任务调度系统">1. 任务调度系统</a></li><li><a href=#2-%e7%bc%93%e5%ad%98%e6%9b%bf%e6%8d%a2%e7%ae%97%e6%b3%95 aria-label="2. 缓存替换算法">2. 缓存替换算法</a></li></ul></li><li><a href=#%e5%ad%a6%e4%b9%a0%e5%bb%ba%e8%ae%ae%e5%92%8c%e6%80%bb%e7%bb%93 aria-label=学习建议和总结>学习建议和总结</a><ul><li><a href=#%e5%ad%a6%e4%b9%a0%e8%b7%af%e5%be%84 aria-label=学习路径>学习路径</a></li><li><a href=#%e5%85%b3%e9%94%ae%e8%a6%81%e7%82%b9 aria-label=关键要点>关键要点</a></li><li><a href=#%e5%b8%b8%e8%a7%81%e8%af%af%e5%8c%ba aria-label=常见误区>常见误区</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=贪心算法概述>贪心算法概述<a hidden class=anchor aria-hidden=true href=#贪心算法概述>#</a></h2><p>**贪心算法（Greedy Algorithm）**是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。贪心算法在算法竞赛和实际工程中都有着重要的地位。</p><h2 id=贪心算法的核心思想>贪心算法的核心思想<a hidden class=anchor aria-hidden=true href=#贪心算法的核心思想>#</a></h2><h3 id=基本原理>基本原理<a hidden class=anchor aria-hidden=true href=#基本原理>#</a></h3><p>贪心算法的核心思想是：</p><ol><li><strong>局部最优选择</strong>：在每一步都做出当前看起来最优的选择</li><li><strong>不回溯</strong>：一旦做出选择，就不再改变</li><li><strong>希望全局最优</strong>：通过局部最优选择达到全局最优解</li></ol><h3 id=贪心选择性质>贪心选择性质<a hidden class=anchor aria-hidden=true href=#贪心选择性质>#</a></h3><p>一个问题能够用贪心算法解决，必须具备以下性质：</p><table><thead><tr><th>性质</th><th>描述</th><th>重要性</th></tr></thead><tbody><tr><td><strong>贪心选择性质</strong></td><td>通过局部最优选择能达到全局最优</td><td>核心性质</td></tr><tr><td><strong>最优子结构</strong></td><td>问题的最优解包含子问题的最优解</td><td>必要条件</td></tr><tr><td><strong>无后效性</strong></td><td>当前选择不影响之前的选择</td><td>保证正确性</td></tr></tbody></table><h2 id=贪心算法设计步骤>贪心算法设计步骤<a hidden class=anchor aria-hidden=true href=#贪心算法设计步骤>#</a></h2><h3 id=1-问题分析>1. 问题分析<a hidden class=anchor aria-hidden=true href=#1-问题分析>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>greedy_algorithm_template</span><span class=p>(</span><span class=n>problem_input</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    贪心算法通用模板
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 步骤1：将问题分解为子问题</span>
</span></span><span class=line><span class=cl>    <span class=n>subproblems</span> <span class=o>=</span> <span class=n>decompose_problem</span><span class=p>(</span><span class=n>problem_input</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 步骤2：确定贪心策略</span>
</span></span><span class=line><span class=cl>    <span class=n>strategy</span> <span class=o>=</span> <span class=n>define_greedy_strategy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 步骤3：按贪心策略排序</span>
</span></span><span class=line><span class=cl>    <span class=n>sorted_items</span> <span class=o>=</span> <span class=n>sort_by_strategy</span><span class=p>(</span><span class=n>subproblems</span><span class=p>,</span> <span class=n>strategy</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 步骤4：逐步构造解</span>
</span></span><span class=line><span class=cl>    <span class=n>solution</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>item</span> <span class=ow>in</span> <span class=n>sorted_items</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>is_feasible</span><span class=p>(</span><span class=n>solution</span><span class=p>,</span> <span class=n>item</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>solution</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>solution</span>
</span></span></code></pre></div><h3 id=2-贪心策略选择>2. 贪心策略选择<a hidden class=anchor aria-hidden=true href=#2-贪心策略选择>#</a></h3><p>常见的贪心策略包括：</p><table><thead><tr><th>策略类型</th><th>描述</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>最大优先</strong></td><td>优先选择最大值</td><td>最大收益问题</td></tr><tr><td><strong>最小优先</strong></td><td>优先选择最小值</td><td>最小成本问题</td></tr><tr><td><strong>比值优先</strong></td><td>按某种比值排序</td><td>效率优化问题</td></tr><tr><td><strong>截止时间优先</strong></td><td>按时间排序</td><td>调度问题</td></tr></tbody></table><h2 id=经典贪心算法问题>经典贪心算法问题<a hidden class=anchor aria-hidden=true href=#经典贪心算法问题>#</a></h2><h3 id=1-活动选择问题>1. 活动选择问题<a hidden class=anchor aria-hidden=true href=#1-活动选择问题>#</a></h3><h4 id=问题描述>问题描述<a hidden class=anchor aria-hidden=true href=#问题描述>#</a></h4><p>给定n个活动，每个活动都有开始时间和结束时间，选择最多的活动使得它们不冲突。</p><h4 id=贪心策略>贪心策略<a hidden class=anchor aria-hidden=true href=#贪心策略>#</a></h4><p><strong>按结束时间排序，优先选择结束时间最早的活动</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>activity_selection</span><span class=p>(</span><span class=n>activities</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    活动选择问题 - 贪心算法
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Args:
</span></span></span><span class=line><span class=cl><span class=s2>        activities: [(start_time, end_time, activity_id), ...]
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Returns:
</span></span></span><span class=line><span class=cl><span class=s2>        selected_activities: 选中的活动列表
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 按结束时间排序</span>
</span></span><span class=line><span class=cl>    <span class=n>activities</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>selected</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>last_end_time</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>activity_id</span> <span class=ow>in</span> <span class=n>activities</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 如果当前活动的开始时间 &gt;= 上一个活动的结束时间</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>start</span> <span class=o>&gt;=</span> <span class=n>last_end_time</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>selected</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>activity_id</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>last_end_time</span> <span class=o>=</span> <span class=n>end</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>selected</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 示例使用</span>
</span></span><span class=line><span class=cl><span class=n>activities</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=s1>&#39;A&#39;</span><span class=p>),</span>   <span class=c1># 活动A: 1-4</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=s1>&#39;B&#39;</span><span class=p>),</span>   <span class=c1># 活动B: 3-5</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=s1>&#39;C&#39;</span><span class=p>),</span>   <span class=c1># 活动C: 0-6</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=s1>&#39;D&#39;</span><span class=p>),</span>   <span class=c1># 活动D: 5-7</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=s1>&#39;E&#39;</span><span class=p>),</span>   <span class=c1># 活动E: 3-9</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=s1>&#39;F&#39;</span><span class=p>),</span>   <span class=c1># 活动F: 5-9</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>6</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=s1>&#39;G&#39;</span><span class=p>),</span>  <span class=c1># 活动G: 6-10</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>8</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=s1>&#39;H&#39;</span><span class=p>),</span>  <span class=c1># 活动H: 8-11</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>8</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=s1>&#39;I&#39;</span><span class=p>),</span>  <span class=c1># 活动I: 8-12</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>14</span><span class=p>,</span> <span class=s1>&#39;J&#39;</span><span class=p>),</span>  <span class=c1># 活动J: 2-14</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>12</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=s1>&#39;K&#39;</span><span class=p>)</span>  <span class=c1># 活动K: 12-16</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>activity_selection</span><span class=p>(</span><span class=n>activities</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;选中的活动:&#34;</span><span class=p>,</span> <span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 输出: [(1, 4, &#39;A&#39;), (5, 7, &#39;D&#39;), (8, 11, &#39;H&#39;), (12, 16, &#39;K&#39;)]</span>
</span></span></code></pre></div><h4 id=正确性证明>正确性证明<a hidden class=anchor aria-hidden=true href=#正确性证明>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>prove_activity_selection</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    活动选择问题正确性证明思路：
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    1. 贪心选择性质：
</span></span></span><span class=line><span class=cl><span class=s2>       - 设最优解为OPT，贪心解为GREEDY
</span></span></span><span class=line><span class=cl><span class=s2>       - 如果OPT的第一个活动不是最早结束的，
</span></span></span><span class=line><span class=cl><span class=s2>         可以替换为最早结束的活动，不会使解变差
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    2. 最优子结构：
</span></span></span><span class=line><span class=cl><span class=s2>       - 选择第一个活动后，剩余问题仍是活动选择问题
</span></span></span><span class=line><span class=cl><span class=s2>       - 原问题的最优解 = 第一个活动 + 子问题的最优解
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span></code></pre></div><h3 id=2-分数背包问题>2. 分数背包问题<a hidden class=anchor aria-hidden=true href=#2-分数背包问题>#</a></h3><h4 id=问题描述-1>问题描述<a hidden class=anchor aria-hidden=true href=#问题描述-1>#</a></h4><p>有一个容量为W的背包和n个物品，每个物品有重量和价值，可以取物品的一部分，求最大价值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fractional_knapsack</span><span class=p>(</span><span class=n>items</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    分数背包问题 - 贪心算法
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Args:
</span></span></span><span class=line><span class=cl><span class=s2>        items: [(weight, value, item_id), ...]
</span></span></span><span class=line><span class=cl><span class=s2>        capacity: 背包容量
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Returns:
</span></span></span><span class=line><span class=cl><span class=s2>        (max_value, selected_items): 最大价值和选中的物品
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 按价值密度（价值/重量）降序排序</span>
</span></span><span class=line><span class=cl>    <span class=n>items</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>/</span><span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>total_value</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>selected_items</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>remaining_capacity</span> <span class=o>=</span> <span class=n>capacity</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>weight</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=n>item_id</span> <span class=ow>in</span> <span class=n>items</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>remaining_capacity</span> <span class=o>&gt;=</span> <span class=n>weight</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 完全装入</span>
</span></span><span class=line><span class=cl>            <span class=n>selected_items</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>weight</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=n>item_id</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>total_value</span> <span class=o>+=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>            <span class=n>remaining_capacity</span> <span class=o>-=</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>remaining_capacity</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 部分装入</span>
</span></span><span class=line><span class=cl>            <span class=n>fraction</span> <span class=o>=</span> <span class=n>remaining_capacity</span> <span class=o>/</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>            <span class=n>selected_items</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>weight</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=n>item_id</span><span class=p>,</span> <span class=n>fraction</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>total_value</span> <span class=o>+=</span> <span class=n>value</span> <span class=o>*</span> <span class=n>fraction</span>
</span></span><span class=line><span class=cl>            <span class=n>remaining_capacity</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>total_value</span><span class=p>,</span> <span class=n>selected_items</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 示例使用</span>
</span></span><span class=line><span class=cl><span class=n>items</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>60</span><span class=p>,</span> <span class=s1>&#39;A&#39;</span><span class=p>),</span>   <span class=c1># 物品A: 重量10, 价值60, 密度6.0</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>20</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=s1>&#39;B&#39;</span><span class=p>),</span>  <span class=c1># 物品B: 重量20, 价值100, 密度5.0</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>30</span><span class=p>,</span> <span class=mi>120</span><span class=p>,</span> <span class=s1>&#39;C&#39;</span><span class=p>)</span>   <span class=c1># 物品C: 重量30, 价值120, 密度4.0</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>max_value</span><span class=p>,</span> <span class=n>selected</span> <span class=o>=</span> <span class=n>fractional_knapsack</span><span class=p>(</span><span class=n>items</span><span class=p>,</span> <span class=mi>50</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;最大价值: </span><span class=si>{</span><span class=n>max_value</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;选中的物品:&#34;</span><span class=p>,</span> <span class=n>selected</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 输出: 最大价值: 240.0</span>
</span></span><span class=line><span class=cl><span class=c1># 选中的物品: [(10, 60, &#39;A&#39;, 1.0), (20, 100, &#39;B&#39;, 1.0), (30, 120, &#39;C&#39;, 0.6667)]</span>
</span></span></code></pre></div><h3 id=3-哈夫曼编码>3. 哈夫曼编码<a hidden class=anchor aria-hidden=true href=#3-哈夫曼编码>#</a></h3><h4 id=问题描述-2>问题描述<a hidden class=anchor aria-hidden=true href=#问题描述-2>#</a></h4><p>给定字符频率，构造最优前缀编码，使得编码总长度最小。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>heapq</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>defaultdict</span><span class=p>,</span> <span class=n>Counter</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>HuffmanNode</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>char</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>freq</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>left</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>right</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>char</span> <span class=o>=</span> <span class=n>char</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>freq</span> <span class=o>=</span> <span class=n>freq</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__lt__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>freq</span> <span class=o>&lt;</span> <span class=n>other</span><span class=o>.</span><span class=n>freq</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>huffman_encoding</span><span class=p>(</span><span class=n>text</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    哈夫曼编码 - 贪心算法
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Args:
</span></span></span><span class=line><span class=cl><span class=s2>        text: 输入文本
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Returns:
</span></span></span><span class=line><span class=cl><span class=s2>        (encoded_text, huffman_tree, codes): 编码结果、哈夫曼树、编码表
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 统计字符频率</span>
</span></span><span class=line><span class=cl>    <span class=n>freq_map</span> <span class=o>=</span> <span class=n>Counter</span><span class=p>(</span><span class=n>text</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 创建优先队列（最小堆）</span>
</span></span><span class=line><span class=cl>    <span class=n>heap</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>char</span><span class=p>,</span> <span class=n>freq</span> <span class=ow>in</span> <span class=n>freq_map</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>heap</span><span class=p>,</span> <span class=n>HuffmanNode</span><span class=p>(</span><span class=n>char</span><span class=p>,</span> <span class=n>freq</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 构建哈夫曼树</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=nb>len</span><span class=p>(</span><span class=n>heap</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 取出频率最小的两个节点</span>
</span></span><span class=line><span class=cl>        <span class=n>left</span> <span class=o>=</span> <span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=n>heap</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>right</span> <span class=o>=</span> <span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=n>heap</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 创建新的内部节点</span>
</span></span><span class=line><span class=cl>        <span class=n>merged</span> <span class=o>=</span> <span class=n>HuffmanNode</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>freq</span><span class=o>=</span><span class=n>left</span><span class=o>.</span><span class=n>freq</span> <span class=o>+</span> <span class=n>right</span><span class=o>.</span><span class=n>freq</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>left</span><span class=o>=</span><span class=n>left</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>right</span><span class=o>=</span><span class=n>right</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>heap</span><span class=p>,</span> <span class=n>merged</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 根节点</span>
</span></span><span class=line><span class=cl>    <span class=n>root</span> <span class=o>=</span> <span class=n>heap</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=k>if</span> <span class=n>heap</span> <span class=k>else</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 生成编码表</span>
</span></span><span class=line><span class=cl>    <span class=n>codes</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>generate_codes</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>code</span><span class=o>=</span><span class=s2>&#34;&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>char</span><span class=p>:</span>  <span class=c1># 叶子节点</span>
</span></span><span class=line><span class=cl>                <span class=n>codes</span><span class=p>[</span><span class=n>node</span><span class=o>.</span><span class=n>char</span><span class=p>]</span> <span class=o>=</span> <span class=n>code</span> <span class=k>if</span> <span class=n>code</span> <span class=k>else</span> <span class=s2>&#34;0&#34;</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>  <span class=c1># 内部节点</span>
</span></span><span class=line><span class=cl>                <span class=n>generate_codes</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>code</span> <span class=o>+</span> <span class=s2>&#34;0&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>generate_codes</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>,</span> <span class=n>code</span> <span class=o>+</span> <span class=s2>&#34;1&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>generate_codes</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 编码文本</span>
</span></span><span class=line><span class=cl>    <span class=n>encoded_text</span> <span class=o>=</span> <span class=s2>&#34;&#34;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>codes</span><span class=p>[</span><span class=n>char</span><span class=p>]</span> <span class=k>for</span> <span class=n>char</span> <span class=ow>in</span> <span class=n>text</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>encoded_text</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=n>codes</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 示例使用</span>
</span></span><span class=line><span class=cl><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;ABRACADABRA&#34;</span>
</span></span><span class=line><span class=cl><span class=n>encoded</span><span class=p>,</span> <span class=n>tree</span><span class=p>,</span> <span class=n>codes</span> <span class=o>=</span> <span class=n>huffman_encoding</span><span class=p>(</span><span class=n>text</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;原文本:&#34;</span><span class=p>,</span> <span class=n>text</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;字符编码:&#34;</span><span class=p>,</span> <span class=n>codes</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;编码结果:&#34;</span><span class=p>,</span> <span class=n>encoded</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;压缩率: </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>encoded</span><span class=p>)</span><span class=si>}</span><span class=s2> / </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>text</span><span class=p>)</span> <span class=o>*</span> <span class=mi>8</span><span class=si>}</span><span class=s2> = </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>encoded</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>text</span><span class=p>)</span> <span class=o>*</span> <span class=mi>8</span><span class=p>)</span><span class=si>:</span><span class=s2>.2%</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 解码函数</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>huffman_decoding</span><span class=p>(</span><span class=n>encoded_text</span><span class=p>,</span> <span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;哈夫曼解码&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>decoded</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>current</span> <span class=o>=</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>bit</span> <span class=ow>in</span> <span class=n>encoded_text</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>bit</span> <span class=o>==</span> <span class=s1>&#39;0&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>left</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>right</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current</span><span class=o>.</span><span class=n>char</span><span class=p>:</span>  <span class=c1># 到达叶子节点</span>
</span></span><span class=line><span class=cl>            <span class=n>decoded</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>current</span><span class=o>.</span><span class=n>char</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span> <span class=o>=</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s2>&#34;&#34;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>decoded</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>decoded</span> <span class=o>=</span> <span class=n>huffman_decoding</span><span class=p>(</span><span class=n>encoded</span><span class=p>,</span> <span class=n>tree</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;解码结果:&#34;</span><span class=p>,</span> <span class=n>decoded</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=4-最小生成树kruskal算法>4. 最小生成树（Kruskal算法）<a hidden class=anchor aria-hidden=true href=#4-最小生成树kruskal算法>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>UnionFind</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;并查集数据结构&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>parent</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>rank</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>find</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>!=</span> <span class=n>x</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>union</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>px</span><span class=p>,</span> <span class=n>py</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>x</span><span class=p>),</span> <span class=bp>self</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>px</span> <span class=o>==</span> <span class=n>py</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>rank</span><span class=p>[</span><span class=n>px</span><span class=p>]</span> <span class=o>&lt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>rank</span><span class=p>[</span><span class=n>py</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>px</span><span class=p>,</span> <span class=n>py</span> <span class=o>=</span> <span class=n>py</span><span class=p>,</span> <span class=n>px</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>[</span><span class=n>py</span><span class=p>]</span> <span class=o>=</span> <span class=n>px</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>rank</span><span class=p>[</span><span class=n>px</span><span class=p>]</span> <span class=o>==</span> <span class=bp>self</span><span class=o>.</span><span class=n>rank</span><span class=p>[</span><span class=n>py</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>rank</span><span class=p>[</span><span class=n>px</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>kruskal_mst</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>edges</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    Kruskal最小生成树算法 - 贪心算法
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Args:
</span></span></span><span class=line><span class=cl><span class=s2>        n: 顶点数量
</span></span></span><span class=line><span class=cl><span class=s2>        edges: [(weight, u, v), ...] 边的列表
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Returns:
</span></span></span><span class=line><span class=cl><span class=s2>        (mst_weight, mst_edges): 最小生成树的权重和边
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 按权重排序</span>
</span></span><span class=line><span class=cl>    <span class=n>edges</span><span class=o>.</span><span class=n>sort</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>uf</span> <span class=o>=</span> <span class=n>UnionFind</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>mst_edges</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>mst_weight</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>weight</span><span class=p>,</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>edges</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>uf</span><span class=o>.</span><span class=n>union</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>):</span>  <span class=c1># 如果不形成环</span>
</span></span><span class=line><span class=cl>            <span class=n>mst_edges</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>weight</span><span class=p>,</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>mst_weight</span> <span class=o>+=</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>mst_edges</span><span class=p>)</span> <span class=o>==</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>:</span>  <span class=c1># 生成树完成</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>mst_weight</span><span class=p>,</span> <span class=n>mst_edges</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 示例使用</span>
</span></span><span class=line><span class=cl><span class=n>edges</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>),</span>   <span class=c1># 边 0-1，权重1</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>),</span>   <span class=c1># 边 0-2，权重2</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>),</span>   <span class=c1># 边 1-2，权重3</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>),</span>   <span class=c1># 边 1-3，权重4</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>),</span>   <span class=c1># 边 2-3，权重5</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>weight</span><span class=p>,</span> <span class=n>mst</span> <span class=o>=</span> <span class=n>kruskal_mst</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=n>edges</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;最小生成树权重: </span><span class=si>{</span><span class=n>weight</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;最小生成树边:&#34;</span><span class=p>,</span> <span class=n>mst</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=5-区间调度问题>5. 区间调度问题<a hidden class=anchor aria-hidden=true href=#5-区间调度问题>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>interval_scheduling</span><span class=p>(</span><span class=n>intervals</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    区间调度问题 - 贪心算法
</span></span></span><span class=line><span class=cl><span class=s2>    选择最多的不重叠区间
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Args:
</span></span></span><span class=line><span class=cl><span class=s2>        intervals: [(start, end, interval_id), ...]
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Returns:
</span></span></span><span class=line><span class=cl><span class=s2>        selected_intervals: 选中的区间列表
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 按结束时间排序</span>
</span></span><span class=line><span class=cl>    <span class=n>intervals</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>selected</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>last_end</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;-inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>interval_id</span> <span class=ow>in</span> <span class=n>intervals</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>start</span> <span class=o>&gt;=</span> <span class=n>last_end</span><span class=p>:</span>  <span class=c1># 不重叠</span>
</span></span><span class=line><span class=cl>            <span class=n>selected</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>interval_id</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>last_end</span> <span class=o>=</span> <span class=n>end</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>selected</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>interval_coloring</span><span class=p>(</span><span class=n>intervals</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    区间着色问题 - 贪心算法
</span></span></span><span class=line><span class=cl><span class=s2>    用最少的颜色给所有区间着色，使得重叠区间颜色不同
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Args:
</span></span></span><span class=line><span class=cl><span class=s2>        intervals: [(start, end, interval_id), ...]
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Returns:
</span></span></span><span class=line><span class=cl><span class=s2>        coloring: {interval_id: color}
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 按开始时间排序</span>
</span></span><span class=line><span class=cl>    <span class=n>intervals</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>coloring</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=n>color_end_times</span> <span class=o>=</span> <span class=p>[]</span>  <span class=c1># 每种颜色的最后结束时间</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>interval_id</span> <span class=ow>in</span> <span class=n>intervals</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 找到可以复用的颜色</span>
</span></span><span class=line><span class=cl>        <span class=n>color</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>end_time</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>color_end_times</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>start</span> <span class=o>&gt;=</span> <span class=n>end_time</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>color</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>color</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>:</span>  <span class=c1># 需要新颜色</span>
</span></span><span class=line><span class=cl>            <span class=n>color</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>color_end_times</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>color_end_times</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>  <span class=c1># 复用颜色</span>
</span></span><span class=line><span class=cl>            <span class=n>color_end_times</span><span class=p>[</span><span class=n>color</span><span class=p>]</span> <span class=o>=</span> <span class=n>end</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>coloring</span><span class=p>[</span><span class=n>interval_id</span><span class=p>]</span> <span class=o>=</span> <span class=n>color</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>coloring</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>color_end_times</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 示例使用</span>
</span></span><span class=line><span class=cl><span class=n>intervals</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=s1>&#39;A&#39;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=s1>&#39;B&#39;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=s1>&#39;C&#39;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=s1>&#39;D&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 区间调度</span>
</span></span><span class=line><span class=cl><span class=n>selected</span> <span class=o>=</span> <span class=n>interval_scheduling</span><span class=p>(</span><span class=n>intervals</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;选中的区间:&#34;</span><span class=p>,</span> <span class=n>selected</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 区间着色</span>
</span></span><span class=line><span class=cl><span class=n>coloring</span><span class=p>,</span> <span class=n>num_colors</span> <span class=o>=</span> <span class=n>interval_coloring</span><span class=p>(</span><span class=n>intervals</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;着色方案:&#34;</span><span class=p>,</span> <span class=n>coloring</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;需要颜色数:&#34;</span><span class=p>,</span> <span class=n>num_colors</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=贪心算法的应用场景>贪心算法的应用场景<a hidden class=anchor aria-hidden=true href=#贪心算法的应用场景>#</a></h2><h3 id=1-调度问题>1. 调度问题<a hidden class=anchor aria-hidden=true href=#1-调度问题>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>job_scheduling_with_deadlines</span><span class=p>(</span><span class=n>jobs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    带截止时间的作业调度 - 贪心算法
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Args:
</span></span></span><span class=line><span class=cl><span class=s2>        jobs: [(profit, deadline, job_id), ...]
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Returns:
</span></span></span><span class=line><span class=cl><span class=s2>        (max_profit, scheduled_jobs): 最大利润和调度的作业
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 按利润降序排序</span>
</span></span><span class=line><span class=cl>    <span class=n>jobs</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 找到最大截止时间</span>
</span></span><span class=line><span class=cl>    <span class=n>max_deadline</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>job</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=k>for</span> <span class=n>job</span> <span class=ow>in</span> <span class=n>jobs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 时间槽数组，-1表示空闲</span>
</span></span><span class=line><span class=cl>    <span class=n>time_slots</span> <span class=o>=</span> <span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>max_deadline</span>
</span></span><span class=line><span class=cl>    <span class=n>scheduled_jobs</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>total_profit</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>profit</span><span class=p>,</span> <span class=n>deadline</span><span class=p>,</span> <span class=n>job_id</span> <span class=ow>in</span> <span class=n>jobs</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 从截止时间往前找空闲时间槽</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>t</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>min</span><span class=p>(</span><span class=n>deadline</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>max_deadline</span> <span class=o>-</span> <span class=mi>1</span><span class=p>),</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>time_slots</span><span class=p>[</span><span class=n>t</span><span class=p>]</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>time_slots</span><span class=p>[</span><span class=n>t</span><span class=p>]</span> <span class=o>=</span> <span class=n>job_id</span>
</span></span><span class=line><span class=cl>                <span class=n>scheduled_jobs</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>profit</span><span class=p>,</span> <span class=n>deadline</span><span class=p>,</span> <span class=n>job_id</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=n>total_profit</span> <span class=o>+=</span> <span class=n>profit</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>total_profit</span><span class=p>,</span> <span class=n>scheduled_jobs</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 示例使用</span>
</span></span><span class=line><span class=cl><span class=n>jobs</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>100</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=s1>&#39;J1&#39;</span><span class=p>),</span>  <span class=c1># 作业J1: 利润100, 截止时间2</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=s1>&#39;J2&#39;</span><span class=p>),</span>   <span class=c1># 作业J2: 利润10, 截止时间1</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>15</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=s1>&#39;J3&#39;</span><span class=p>),</span>   <span class=c1># 作业J3: 利润15, 截止时间2</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=mi>27</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=s1>&#39;J4&#39;</span><span class=p>),</span>   <span class=c1># 作业J4: 利润27, 截止时间1</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>profit</span><span class=p>,</span> <span class=n>scheduled</span> <span class=o>=</span> <span class=n>job_scheduling_with_deadlines</span><span class=p>(</span><span class=n>jobs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;最大利润: </span><span class=si>{</span><span class=n>profit</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;调度的作业:&#34;</span><span class=p>,</span> <span class=n>scheduled</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=2-图论问题>2. 图论问题<a hidden class=anchor aria-hidden=true href=#2-图论问题>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>dijkstra_shortest_path</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>start</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    Dijkstra最短路径算法 - 贪心算法
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Args:
</span></span></span><span class=line><span class=cl><span class=s2>        graph: {node: [(neighbor, weight), ...]}
</span></span></span><span class=line><span class=cl><span class=s2>        start: 起始节点
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    Returns:
</span></span></span><span class=line><span class=cl><span class=s2>        distances: {node: shortest_distance}
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nn>heapq</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>distances</span> <span class=o>=</span> <span class=p>{</span><span class=n>node</span><span class=p>:</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span> <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>distances</span><span class=p>[</span><span class=n>start</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 优先队列：(distance, node)</span>
</span></span><span class=line><span class=cl>    <span class=n>pq</span> <span class=o>=</span> <span class=p>[(</span><span class=mi>0</span><span class=p>,</span> <span class=n>start</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>pq</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>current_dist</span><span class=p>,</span> <span class=n>current_node</span> <span class=o>=</span> <span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=n>pq</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_node</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>visited</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>current_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 更新邻居节点的距离</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbor</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>graph</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>current_node</span><span class=p>,</span> <span class=p>[]):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>neighbor</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>new_dist</span> <span class=o>=</span> <span class=n>current_dist</span> <span class=o>+</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>new_dist</span> <span class=o>&lt;</span> <span class=n>distances</span><span class=p>[</span><span class=n>neighbor</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=n>distances</span><span class=p>[</span><span class=n>neighbor</span><span class=p>]</span> <span class=o>=</span> <span class=n>new_dist</span>
</span></span><span class=line><span class=cl>                    <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>pq</span><span class=p>,</span> <span class=p>(</span><span class=n>new_dist</span><span class=p>,</span> <span class=n>neighbor</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>distances</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 示例使用</span>
</span></span><span class=line><span class=cl><span class=n>graph</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;A&#39;</span><span class=p>:</span> <span class=p>[(</span><span class=s1>&#39;B&#39;</span><span class=p>,</span> <span class=mi>4</span><span class=p>),</span> <span class=p>(</span><span class=s1>&#39;C&#39;</span><span class=p>,</span> <span class=mi>2</span><span class=p>)],</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;B&#39;</span><span class=p>:</span> <span class=p>[(</span><span class=s1>&#39;C&#39;</span><span class=p>,</span> <span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=s1>&#39;D&#39;</span><span class=p>,</span> <span class=mi>5</span><span class=p>)],</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;C&#39;</span><span class=p>:</span> <span class=p>[(</span><span class=s1>&#39;D&#39;</span><span class=p>,</span> <span class=mi>8</span><span class=p>),</span> <span class=p>(</span><span class=s1>&#39;E&#39;</span><span class=p>,</span> <span class=mi>10</span><span class=p>)],</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;D&#39;</span><span class=p>:</span> <span class=p>[(</span><span class=s1>&#39;E&#39;</span><span class=p>,</span> <span class=mi>2</span><span class=p>)],</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;E&#39;</span><span class=p>:</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>distances</span> <span class=o>=</span> <span class=n>dijkstra_shortest_path</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=s1>&#39;A&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;从A到各点的最短距离:&#34;</span><span class=p>,</span> <span class=n>distances</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=贪心算法的局限性>贪心算法的局限性<a hidden class=anchor aria-hidden=true href=#贪心算法的局限性>#</a></h2><h3 id=1-不适用的问题>1. 不适用的问题<a hidden class=anchor aria-hidden=true href=#1-不适用的问题>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>knapsack_01_counterexample</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    0-1背包问题：贪心算法不能得到最优解
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 物品: (重量, 价值)</span>
</span></span><span class=line><span class=cl>    <span class=n>items</span> <span class=o>=</span> <span class=p>[(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>60</span><span class=p>),</span> <span class=p>(</span><span class=mi>20</span><span class=p>,</span> <span class=mi>100</span><span class=p>),</span> <span class=p>(</span><span class=mi>30</span><span class=p>,</span> <span class=mi>120</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=n>capacity</span> <span class=o>=</span> <span class=mi>50</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 贪心策略：按价值密度排序</span>
</span></span><span class=line><span class=cl>    <span class=c1># 密度: [6.0, 5.0, 4.0]</span>
</span></span><span class=line><span class=cl>    <span class=c1># 贪心选择: 物品1(10,60) + 物品2(20,100) = 价值160</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 最优解: 物品2(20,100) + 物品3(30,120) = 价值220</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;贪心算法不适用于0-1背包问题&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;贪心解: 160, 最优解: 220&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>coin_change_counterexample</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    硬币找零问题：某些币值系统下贪心算法不能得到最优解
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 币值系统: [1, 3, 4]</span>
</span></span><span class=line><span class=cl>    <span class=c1># 目标金额: 6</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 贪心策略：优先使用大面额</span>
</span></span><span class=line><span class=cl>    <span class=c1># 贪心解: 4 + 1 + 1 = 3枚硬币</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 最优解: 3 + 3 = 2枚硬币</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;某些币值系统下，贪心算法不能得到最优解&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;贪心解: 3枚硬币, 最优解: 2枚硬币&#34;</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=2-贪心算法的适用条件>2. 贪心算法的适用条件<a hidden class=anchor aria-hidden=true href=#2-贪心算法的适用条件>#</a></h3><table><thead><tr><th>条件</th><th>说明</th><th>检验方法</th></tr></thead><tbody><tr><td><strong>贪心选择性质</strong></td><td>局部最优能导致全局最优</td><td>数学证明或反证法</td></tr><tr><td><strong>最优子结构</strong></td><td>子问题的最优解构成原问题的最优解</td><td>递归分析</td></tr><tr><td><strong>无后效性</strong></td><td>当前选择不影响之前的选择</td><td>状态分析</td></tr></tbody></table><h2 id=贪心算法设计技巧>贪心算法设计技巧<a hidden class=anchor aria-hidden=true href=#贪心算法设计技巧>#</a></h2><h3 id=1-策略选择指南>1. 策略选择指南<a hidden class=anchor aria-hidden=true href=#1-策略选择指南>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>strategy_selection_guide</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    贪心策略选择指南
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>strategies</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;最早截止时间优先&#34;</span><span class=p>:</span> <span class=s2>&#34;调度问题，避免错过截止时间&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;最短处理时间优先&#34;</span><span class=p>:</span> <span class=s2>&#34;最小化平均等待时间&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;最高价值密度优先&#34;</span><span class=p>:</span> <span class=s2>&#34;背包类问题，最大化单位收益&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;最小权重优先&#34;</span><span class=p>:</span> <span class=s2>&#34;生成树问题，最小化总成本&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;最大利润优先&#34;</span><span class=p>:</span> <span class=s2>&#34;选择问题，最大化总收益&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>strategy</span><span class=p>,</span> <span class=n>application</span> <span class=ow>in</span> <span class=n>strategies</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;</span><span class=si>{</span><span class=n>strategy</span><span class=si>}</span><span class=s2>: </span><span class=si>{</span><span class=n>application</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=2-正确性证明方法>2. 正确性证明方法<a hidden class=anchor aria-hidden=true href=#2-正确性证明方法>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>greedy_proof_methods</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    贪心算法正确性证明方法
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>methods</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;交换论证&#34;</span><span class=p>:</span> <span class=s2>&#34;证明贪心选择可以替换最优解中的选择&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;归纳法&#34;</span><span class=p>:</span> <span class=s2>&#34;证明每一步贪心选择都保持最优性&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;反证法&#34;</span><span class=p>:</span> <span class=s2>&#34;假设贪心解不是最优解，推出矛盾&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;切割粘贴&#34;</span><span class=p>:</span> <span class=s2>&#34;将最优解分割重组，证明贪心解不差&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>method</span><span class=p>,</span> <span class=n>description</span> <span class=ow>in</span> <span class=n>methods</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;</span><span class=si>{</span><span class=n>method</span><span class=si>}</span><span class=s2>: </span><span class=si>{</span><span class=n>description</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=实际应用案例>实际应用案例<a hidden class=anchor aria-hidden=true href=#实际应用案例>#</a></h2><h3 id=1-任务调度系统>1. 任务调度系统<a hidden class=anchor aria-hidden=true href=#1-任务调度系统>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>TaskScheduler</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;基于贪心算法的任务调度器&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>tasks</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>add_task</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>task_id</span><span class=p>,</span> <span class=n>priority</span><span class=p>,</span> <span class=n>duration</span><span class=p>,</span> <span class=n>deadline</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;添加任务&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>tasks</span><span class=o>.</span><span class=n>append</span><span class=p>({</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;id&#39;</span><span class=p>:</span> <span class=n>task_id</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;priority&#39;</span><span class=p>:</span> <span class=n>priority</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;duration&#39;</span><span class=p>:</span> <span class=n>duration</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;deadline&#39;</span><span class=p>:</span> <span class=n>deadline</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>schedule_by_priority</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;按优先级调度&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>sorted</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>tasks</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=s1>&#39;priority&#39;</span><span class=p>],</span> <span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>schedule_by_deadline</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;按截止时间调度&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>sorted</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>tasks</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=s1>&#39;deadline&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>schedule_by_shortest_job_first</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;最短作业优先调度&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>sorted</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>tasks</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=s1>&#39;duration&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 示例使用</span>
</span></span><span class=line><span class=cl><span class=n>scheduler</span> <span class=o>=</span> <span class=n>TaskScheduler</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>scheduler</span><span class=o>.</span><span class=n>add_task</span><span class=p>(</span><span class=s1>&#39;T1&#39;</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>scheduler</span><span class=o>.</span><span class=n>add_task</span><span class=p>(</span><span class=s1>&#39;T2&#39;</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>50</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>scheduler</span><span class=o>.</span><span class=n>add_task</span><span class=p>(</span><span class=s1>&#39;T3&#39;</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>15</span><span class=p>,</span> <span class=mi>80</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;按优先级调度:&#34;</span><span class=p>,</span> <span class=n>scheduler</span><span class=o>.</span><span class=n>schedule_by_priority</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;按截止时间调度:&#34;</span><span class=p>,</span> <span class=n>scheduler</span><span class=o>.</span><span class=n>schedule_by_deadline</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;最短作业优先:&#34;</span><span class=p>,</span> <span class=n>scheduler</span><span class=o>.</span><span class=n>schedule_by_shortest_job_first</span><span class=p>())</span>
</span></span></code></pre></div><h3 id=2-缓存替换算法>2. 缓存替换算法<a hidden class=anchor aria-hidden=true href=#2-缓存替换算法>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>LRUCache</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;基于贪心思想的LRU缓存&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>capacity</span> <span class=o>=</span> <span class=n>capacity</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>cache</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>access_order</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;获取缓存值&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>key</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>cache</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 更新访问顺序（贪心策略：最近使用的放在最后）</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>access_order</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>access_order</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>cache</span><span class=p>[</span><span class=n>key</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>put</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;设置缓存值&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>key</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>cache</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 更新现有键</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>cache</span><span class=p>[</span><span class=n>key</span><span class=p>]</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>access_order</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>access_order</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 添加新键</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>cache</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=bp>self</span><span class=o>.</span><span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 贪心策略：移除最久未使用的键</span>
</span></span><span class=line><span class=cl>                <span class=n>lru_key</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>access_order</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>del</span> <span class=bp>self</span><span class=o>.</span><span class=n>cache</span><span class=p>[</span><span class=n>lru_key</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>cache</span><span class=p>[</span><span class=n>key</span><span class=p>]</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>access_order</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 示例使用</span>
</span></span><span class=line><span class=cl><span class=n>cache</span> <span class=o>=</span> <span class=n>LRUCache</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>cache</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=s1>&#39;A&#39;</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>cache</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=s1>&#39;B&#39;</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>cache</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=s1>&#39;C&#39;</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;缓存状态:&#34;</span><span class=p>,</span> <span class=n>cache</span><span class=o>.</span><span class=n>cache</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>cache</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;A&#39;</span><span class=p>)</span>  <span class=c1># 访问A</span>
</span></span><span class=line><span class=cl><span class=n>cache</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=s1>&#39;D&#39;</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>  <span class=c1># 添加D，应该移除B</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;添加D后:&#34;</span><span class=p>,</span> <span class=n>cache</span><span class=o>.</span><span class=n>cache</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=学习建议和总结>学习建议和总结<a hidden class=anchor aria-hidden=true href=#学习建议和总结>#</a></h2><h3 id=学习路径>学习路径<a hidden class=anchor aria-hidden=true href=#学习路径>#</a></h3><ol><li><strong>理解核心概念</strong>：掌握贪心选择性质和最优子结构</li><li><strong>练习经典问题</strong>：活动选择、背包问题、最短路径等</li><li><strong>学会证明方法</strong>：交换论证、归纳法、反证法</li><li><strong>识别适用场景</strong>：判断问题是否适合贪心算法</li><li><strong>实际应用练习</strong>：调度、优化、图论等实际问题</li></ol><h3 id=关键要点>关键要点<a hidden class=anchor aria-hidden=true href=#关键要点>#</a></h3><table><thead><tr><th>要点</th><th>说明</th></tr></thead><tbody><tr><td><strong>策略选择</strong></td><td>正确的贪心策略是算法成功的关键</td></tr><tr><td><strong>正确性证明</strong></td><td>必须证明贪心选择能得到最优解</td></tr><tr><td><strong>适用性判断</strong></td><td>不是所有问题都适合贪心算法</td></tr><tr><td><strong>效率优势</strong></td><td>贪心算法通常具有较低的时间复杂度</td></tr></tbody></table><h3 id=常见误区>常见误区<a hidden class=anchor aria-hidden=true href=#常见误区>#</a></h3><ol><li><strong>盲目应用</strong>：不验证贪心选择性质就使用贪心算法</li><li><strong>策略错误</strong>：选择了错误的贪心策略</li><li><strong>忽略证明</strong>：没有证明算法的正确性</li><li><strong>适用范围</strong>：将贪心算法应用到不适合的问题上</li></ol><p>贪心算法是算法设计中的重要思想，虽然不能解决所有优化问题，但在适用的场景下能够提供简洁高效的解决方案。掌握贪心算法的关键在于理解其适用条件，选择正确的贪心策略，并能够证明算法的正确性。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://tyhzxh.github.io/tags/%E7%AE%97%E6%B3%95/>算法</a></li><li><a href=https://tyhzxh.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/>贪心算法</a></li><li><a href=https://tyhzxh.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/>算法设计</a></li><li><a href=https://tyhzxh.github.io/tags/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/>优化问题</a></li><li><a href=https://tyhzxh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a></li></ul><nav class=paginav><a class=prev href=https://tyhzxh.github.io/posts/recursion-and-divide-conquer/><span class=title>« Prev</span><br><span>递归与分治算法详解</span>
</a><a class=next href=https://tyhzxh.github.io/posts/prefix-sum-algorithm/><span class=title>Next »</span><br><span>前缀和算法详解与应用</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 贪心算法详解：从基础概念到经典问题 on x" href="https://x.com/intent/tweet/?text=%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e8%af%a6%e8%a7%a3%ef%bc%9a%e4%bb%8e%e5%9f%ba%e7%a1%80%e6%a6%82%e5%bf%b5%e5%88%b0%e7%bb%8f%e5%85%b8%e9%97%ae%e9%a2%98&amp;url=https%3a%2f%2ftyhzxh.github.io%2fposts%2fgreedy-algorithm-guide%2f&amp;hashtags=%e7%ae%97%e6%b3%95%2c%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%2c%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%2c%e4%bc%98%e5%8c%96%e9%97%ae%e9%a2%98%2c%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 贪心算法详解：从基础概念到经典问题 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ftyhzxh.github.io%2fposts%2fgreedy-algorithm-guide%2f&amp;title=%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e8%af%a6%e8%a7%a3%ef%bc%9a%e4%bb%8e%e5%9f%ba%e7%a1%80%e6%a6%82%e5%bf%b5%e5%88%b0%e7%bb%8f%e5%85%b8%e9%97%ae%e9%a2%98&amp;summary=%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e8%af%a6%e8%a7%a3%ef%bc%9a%e4%bb%8e%e5%9f%ba%e7%a1%80%e6%a6%82%e5%bf%b5%e5%88%b0%e7%bb%8f%e5%85%b8%e9%97%ae%e9%a2%98&amp;source=https%3a%2f%2ftyhzxh.github.io%2fposts%2fgreedy-algorithm-guide%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 贪心算法详解：从基础概念到经典问题 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2ftyhzxh.github.io%2fposts%2fgreedy-algorithm-guide%2f&title=%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e8%af%a6%e8%a7%a3%ef%bc%9a%e4%bb%8e%e5%9f%ba%e7%a1%80%e6%a6%82%e5%bf%b5%e5%88%b0%e7%bb%8f%e5%85%b8%e9%97%ae%e9%a2%98"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 贪心算法详解：从基础概念到经典问题 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ftyhzxh.github.io%2fposts%2fgreedy-algorithm-guide%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 贪心算法详解：从基础概念到经典问题 on whatsapp" href="https://api.whatsapp.com/send?text=%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e8%af%a6%e8%a7%a3%ef%bc%9a%e4%bb%8e%e5%9f%ba%e7%a1%80%e6%a6%82%e5%bf%b5%e5%88%b0%e7%bb%8f%e5%85%b8%e9%97%ae%e9%a2%98%20-%20https%3a%2f%2ftyhzxh.github.io%2fposts%2fgreedy-algorithm-guide%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 贪心算法详解：从基础概念到经典问题 on telegram" href="https://telegram.me/share/url?text=%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e8%af%a6%e8%a7%a3%ef%bc%9a%e4%bb%8e%e5%9f%ba%e7%a1%80%e6%a6%82%e5%bf%b5%e5%88%b0%e7%bb%8f%e5%85%b8%e9%97%ae%e9%a2%98&amp;url=https%3a%2f%2ftyhzxh.github.io%2fposts%2fgreedy-algorithm-guide%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 贪心算法详解：从基础概念到经典问题 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e8%af%a6%e8%a7%a3%ef%bc%9a%e4%bb%8e%e5%9f%ba%e7%a1%80%e6%a6%82%e5%bf%b5%e5%88%b0%e7%bb%8f%e5%85%b8%e9%97%ae%e9%a2%98&u=https%3a%2f%2ftyhzxh.github.io%2fposts%2fgreedy-algorithm-guide%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tyhzxh.github.io/>tyhzxh的个人博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>